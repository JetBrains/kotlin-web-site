<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2025-06-25T13:01:20.391107927"><meta name="build-number" content="637"><script>
    (function (w, d, s, l, i) {
        w[l] = w[l] || [];
        w[l].push({'gtm.start': new Date().getTime(), event: 'gtm.js'});
        var f = d.getElementsByTagName(s)[0], j = d.createElement(s), dl = l != 'dataLayer' ? '&amp;l=' + l : '';
        j.async = true;
        j.src = '//www.googletagmanager.com/gtm.js?id=' + i + dl;
        f.parentNode.insertBefore(j, f);
    })(window, document, 'script', 'dataLayer', 'GTM-5P98');
</script>
<script src="https://resources.jetbrains.com/storage/help-app/v6/analytics.js"></script>
<title>The basics of Kotlin Multiplatform project structure | Kotlin Multiplatform Documentation</title><script type="application/json" id="virtual-toc-data">[{"id":"common-code","level":0,"title":"Common code","anchor":"#common-code"},{"id":"targets","level":0,"title":"Targets","anchor":"#targets"},{"id":"source-sets","level":0,"title":"Source sets","anchor":"#source-sets"},{"id":"integration-with-tests","level":0,"title":"Integration with tests","anchor":"#integration-with-tests"},{"id":"what-s-next","level":0,"title":"What\u0027s next?","anchor":"#what-s-next"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b454/app.css" rel="stylesheet"><link rel="manifest" href="https://www.jetbrains.com/site.webmanifest"><link rel="icon" type="image/x-icon" sizes="16x16" href="https://resources.jetbrains.com/storage/ui/favicons/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="https://resources.jetbrains.com/storage/ui/favicons/apple-touch-icon-57x57.png"><link rel="icon" type="image/png" sizes="96x96" href="https://resources.jetbrains.com/storage/ui/favicons/apple-touch-icon-60x60.png"><link rel="icon" type="image/png" sizes="300x300" href="https://resources.jetbrains.com/storage/ui/favicons/apple-touch-icon-72x72.png"><link rel="icon" type="image/png" sizes="500x500" href="https://resources.jetbrains.com/storage/ui/favicons/apple-touch-icon-76x76.png"><meta name="image" content="https://resources.jetbrains.com/storage/products/jetbrains/img/meta/preview.png"><!-- Open Graph --><meta property="og:title" content="The basics of Kotlin Multiplatform project structure | Kotlin Multiplatform"><meta property="og:description" content=""><meta property="og:image" content="https://resources.jetbrains.com/storage/products/jetbrains/img/meta/preview.png"><meta property="og:site_name" content="Kotlin Multiplatform Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-discover-project.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@kotlin"><meta name="twitter:title" content="The basics of Kotlin Multiplatform project structure | Kotlin Multiplatform"><meta name="twitter:description" content=""><meta name="twitter:creator" content="@kotlin"><meta name="twitter:image:src" content="https://resources.jetbrains.com/storage/products/jetbrains/img/meta/preview.png"><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-discover-project.html#webpage",
    "url": "https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-discover-project.html",
    "name": "The basics of Kotlin Multiplatform project structure | Kotlin Multiplatform",
    "description": "",
    "image": "https://resources.jetbrains.com/storage/products/jetbrains/img/meta/preview.png",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "https://www.jetbrains.com/help/kotlin-multiplatform-dev/#website",
    "url": "https://www.jetbrains.com/help/kotlin-multiplatform-dev/",
    "name": "Kotlin Multiplatform Help"
}</script><!-- End Schema.org --><meta name="msapplication-TileColor" content="#000000"/>
<meta name="msapplication-TileImage"
      content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"/>
<meta name="msapplication-square70x70logo"
      content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"/>
<meta name="msapplication-square150x150logo"
      content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"/>
<meta name="msapplication-wide310x150logo"
      content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"/>
<meta name="msapplication-square310x310logo"
      content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"/>
<script>document.cookie="wh_theme=light;expires="+(new Date(Date.now()+500000000).toUTCString())+"; path=/;";</script>
<style>
<!--slack icon-->
[data-test="footer-socials"] [data-test="button"][title*="Kotlin Multiplatform Development Feed"]{position:relative;}
[data-test="footer-socials"] [data-test="button"][title*="Kotlin Multiplatform Development Feed"] svg{visibility:hidden;}
[data-test="footer-socials"] [data-test="button"][title*="Kotlin Multiplatform Development Feed"]::before{
display:block;content:"";position:absolute;top:0;bottom:0;left:0;right:0;
background:url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="%23fff"><path d="M9.586 6.601h1.9v-1.9a1.837 1.837 0 00-1.9-1.9 1.9 1.9 0 000 3.8zm1.9 7.6v4.7a1.837 1.837 0 01-1.9 1.9 1.9 1.9 0 01-1.9-1.9v-4.7a1.899 1.899 0 011.9-1.9 1.837 1.837 0 011.9 1.9zm-5.864 1.773a1.839 1.839 0 01-.737.127 1.9 1.9 0 010-3.8h1.9v1.9a1.839 1.839 0 01-1.163 1.773zm3.963-4.673h-4.7a1.9 1.9 0 010-3.8h4.7a1.838 1.838 0 011.9 1.9 1.9 1.9 0 01-1.9 1.9zm11.4-1.9a1.967 1.967 0 00-1.9-1.9 1.899 1.899 0 00-1.9 1.9v1.9h1.9a1.9 1.9 0 001.9-1.9zm-5.862 1.773a1.839 1.839 0 01-.738.127 1.9 1.9 0 01-1.9-1.9v-4.7a1.839 1.839 0 011.9-1.9 1.898 1.898 0 011.9 1.9v4.7a1.837 1.837 0 01-1.162 1.773zm-.738 9.628a1.839 1.839 0 001.9-1.9 1.9 1.9 0 00-1.9-1.9h-1.9v1.9a1.899 1.899 0 001.9 1.9zm4.7-4.7h-4.7a1.9 1.9 0 110-3.8h4.7a1.836 1.836 0 011.9 1.9 1.9 1.9 0 01-1.9 1.9z"/></svg>') no-repeat center;background-size:20px 20px;}
[data-test="footer-socials"]+.jb-footer__legal{flex-basis:100%;margin-top:8px;}

<!--Drop any switches and set default theme-->
.wh-header__switchers{display:none!important}
</style></head><body data-id="multiplatform-discover-project" data-main-title="The basics of Kotlin Multiplatform project structure" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Explore project structure" data-edit-url="https://github.com/JetBrains/kotlin-multiplatform-dev-docs/edit/master/topics/development/multiplatform-discover-project.md"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Kotlin Multiplatform  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="multiplatform-discover-project" id="multiplatform-discover-project.md">The basics of Kotlin Multiplatform project structure</h1><p id="-adzc8b_2">With Kotlin Multiplatform, you can share code among different platforms. This article explains the constraints of the shared code, how to distinguish between shared and platform-specific parts of your code, and how to specify the platforms on which this shared code works.</p><p id="-adzc8b_3">You'll also learn the core concepts of Kotlin Multiplatform project setup, such as common code, targets, platform-specific and intermediate source sets, and test integration. That will help you set up your multiplatform projects in the future.</p><p id="-adzc8b_4">The model presented here is simplified compared to the one used by Kotlin. However, this basic model should be adequate for the majority of cases.</p><section class="chapter"><h2 id="common-code" data-toc="common-code">Common code</h2><p id="-adzc8b_10"><span class="emphasis" id="-adzc8b_21">Common code</span> is the Kotlin code shared among different platforms.</p><p id="-adzc8b_11">Consider the simple &quot;Hello, World&quot; example:</p><div class="code-block" data-lang="kotlin">
fun greeting() {
    println(&quot;Hello, Kotlin Multiplatform!&quot;)
}
</div><p id="-adzc8b_13">Kotlin code shared among platforms is typically located in the <code class="code" id="-adzc8b_22">commonMain</code> directory. The location of code files is important, as it affects the list of platforms to which this code is compiled.</p><p id="-adzc8b_14">The Kotlin compiler gets the source code as input and produces a set of platform-specific binaries as a result. When compiling multiplatform projects, it can produce multiple binaries from the same code. For example, the compiler can produce JVM <code class="code" id="-adzc8b_23">.class</code> files and native executable files from the same Kotlin file:</p><figure id="-adzc8b_15"><img alt="Common code" src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/common-code-diagram.svg" title="Common code" width="700" height="263"></figure><p id="-adzc8b_16">Not every piece of Kotlin code can be compiled to all platforms. The Kotlin compiler prevents you from using platform-specific functions or classes in your common code since this code can't be compiled to a different platform.</p><p id="-adzc8b_17">For instance, you can't use the <code class="code" id="-adzc8b_24">java.io.File</code> dependency from the common code. It's a part of the JDK, while common code is also compiled to native code, where the JDK classes are not available:</p><figure id="-adzc8b_18"><img alt="Unresolved Java reference" src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/unresolved-java-reference.png" title="Unresolved Java reference" width="500" height="128"></figure><p id="-adzc8b_19">In common code, you can use Kotlin Multiplatform libraries. These libraries provide a common API that can be implemented differently on different platforms. In this case, platform-specific APIs serve as extra parts, and trying to use such an API in common code results in an error.</p><p id="-adzc8b_20">For example, <code class="code" id="-adzc8b_25">kotlinx.coroutines</code> is a Kotlin Multiplatform library that supports all targets, but it also has a platform-specific part that converts <code class="code" id="-adzc8b_26">kotlinx.coroutines</code> concurrent primitives to JDK concurrent primitives, like <code class="code" id="-adzc8b_27">fun CoroutinesDispatcher.asExecutor(): Executor</code>. This additional part of the API isn't available in <code class="code" id="-adzc8b_28">commonMain</code>.</p></section><section class="chapter"><h2 id="targets" data-toc="targets">Targets</h2><p id="-adzc8b_29">Targets define the platforms to which Kotlin compiles the common code. These could be, for example, the JVM, JS, Android, iOS, or Linux. The previous example compiled the common code to the JVM and native targets.</p><p id="-adzc8b_30">A <span class="emphasis" id="-adzc8b_41">Kotlin target</span> is an identifier that describes a compilation target. It defines the format of the produced binaries, available language constructions, and allowed dependencies.</p><aside class="prompt" data-type="note" data-title="" id="-adzc8b_31"><p id="-adzc8b_42">Targets can also be referred to as platforms. See the full <a href="multiplatform-dsl-reference.html#targets" id="-adzc8b_43">list of supported targets</a>.</p></aside><p id="-adzc8b_32">You should first <span class="emphasis" id="-adzc8b_44">declare</span> a target to instruct Kotlin to compile code for that specific target. In Gradle, you declare targets using predefined DSL calls inside the <code class="code" id="-adzc8b_45">kotlin {}</code> block:</p><div class="code-block" data-lang="kotlin">
kotlin {
    jvm() // Declares a JVM target
    iosArm64() // Declares a target that corresponds to 64-bit iPhones
}
</div><p id="-adzc8b_34">This way, each multiplatform project defines a set of supported targets. See the <a href="multiplatform-hierarchy.html" id="-adzc8b_46">Hierarchical project structure</a> section to learn more about declaring targets in your build scripts.</p><p id="-adzc8b_35">With the <code class="code" id="-adzc8b_47">jvm</code> and <code class="code" id="-adzc8b_48">iosArm64</code> targets declared, the common code in <code class="code" id="-adzc8b_49">commonMain</code> will be compiled to these targets:</p><figure id="-adzc8b_36"><img alt="Targets" src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/target-diagram.svg" title="Targets" width="700" height="270"></figure><p id="-adzc8b_37">To understand which code is going to be compiled to a specific target, you can think of a target as a label attached to Kotlin source files. Kotlin uses these labels to determine how to compile your code, which binaries to produce, and which language constructions and dependencies are allowed in that code.</p><p id="-adzc8b_38">If you want to compile the <code class="code" id="-adzc8b_50">greeting.kt</code> file to <code class="code" id="-adzc8b_51">.js</code> as well, you only need to declare the JS target. The code in <code class="code" id="-adzc8b_52">commonMain</code> then receives an additional <code class="code" id="-adzc8b_53">js</code> label, corresponding to the JS target, which instructs Kotlin to produce <code class="code" id="-adzc8b_54">.js</code> files:</p><figure id="-adzc8b_39"><img alt="Target labels" src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/target-labels-diagram.svg" title="Target labels" width="700" height="291"></figure><p id="-adzc8b_40">That's how the Kotlin compiler works with the common code compiled to all the declared targets. See <a href="#source-sets" id="-adzc8b_55">Source sets</a> to learn how to write platform-specific code.</p></section><section class="chapter"><h2 id="source-sets" data-toc="source-sets">Source sets</h2><p id="-adzc8b_56">A <span class="emphasis" id="-adzc8b_68">Kotlin source set</span> is a set of source files with its own targets, dependencies, and compiler options. It's the main way to share code in multiplatform projects.</p><p id="-adzc8b_57">Each source set in a multiplatform project:</p><ul class="list _bullet" id="-adzc8b_58"><li class="list__item" id="-adzc8b_69"><p>Has a name that is unique for a given project.</p></li><li class="list__item" id="-adzc8b_70"><p>Contains a set of source files and resources, usually stored in the directory with the name of the source set.</p></li><li class="list__item" id="-adzc8b_71"><p>Specifies a set of targets to which the code in this source set compiles. These targets impact which language constructions and dependencies are available in this source set.</p></li><li class="list__item" id="-adzc8b_72"><p>Defines its own dependencies and the compiler options.</p></li></ul><p id="-adzc8b_59">Kotlin provides a bunch of predefined source sets. One of them is <code class="code" id="-adzc8b_73">commonMain</code>, which is present in all multiplatform projects and compiles to all declared targets.</p><p id="-adzc8b_60">You interact with source sets as directories inside <code class="code" id="-adzc8b_74">src</code> in Kotlin Multiplatform projects. For example, a project with the <code class="code" id="-adzc8b_75">commonMain</code>, <code class="code" id="-adzc8b_76">iosMain</code>, and <code class="code" id="-adzc8b_77">jvmMain</code> source sets has the following structure:</p><figure id="-adzc8b_61"><img alt="Shared sources" src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/src-directory-diagram.png" title="Shared sources" width="350" height="234"></figure><p id="-adzc8b_62">In Gradle scripts, you access source sets by name inside the <code class="code" id="-adzc8b_78">kotlin.sourceSets {}</code> block:</p><div class="code-block" data-lang="kotlin">
kotlin {
    // Targets declaration:
    // â€¦

    // Source set declaration:
    sourceSets {
        commonMain {
            // Configure the commonMain source set
        }
    }
}
</div><p id="-adzc8b_64">Aside from <code class="code" id="-adzc8b_79">commonMain</code>, other source sets can be either platform-specific or intermediate.</p><section class="chapter"><h3 id="platform-specific-source-sets" data-toc="platform-specific-source-sets">Platform-specific source sets</h3><p id="-adzc8b_80">While having only common code is convenient, it's not always possible. Code in <code class="code" id="-adzc8b_85">commonMain</code> compiles to all declared targets, and Kotlin doesn't allow you to use any platform-specific APIs there.</p><p id="-adzc8b_81">In a multiplatform project with native and JS targets, the following code in <code class="code" id="-adzc8b_86">commonMain</code> doesn't compile:</p><div class="code-block" data-lang="kotlin">
// commonMain/kotlin/common.kt
// Doesn't compile in common code
fun greeting() {
    java.io.File(&quot;greeting.txt&quot;).writeText(&quot;Hello, Multiplatform!&quot;)
}
</div><p id="-adzc8b_83">As a solution, Kotlin creates platform-specific source sets, also referred to as platform source sets. Each target has a corresponding platform source set that compiles for only that target. For example, a <code class="code" id="-adzc8b_87">jvm</code> target has the corresponding <code class="code" id="-adzc8b_88">jvmMain</code> source set that compiles to only the JVM. Kotlin allows using platform-specific dependencies in these source sets, for instance, JDK in <code class="code" id="-adzc8b_89">jvmMain</code>:</p><div class="code-block" data-lang="kotlin">
// jvmMain/kotlin/jvm.kt
// You can use Java dependencies in the `jvmMain` source set
fun jvmGreeting() {
    java.io.File(&quot;greeting.txt&quot;).writeText(&quot;Hello, Multiplatform!&quot;)
}
</div></section><section class="chapter"><h3 id="compilation-to-a-specific-target" data-toc="compilation-to-a-specific-target">Compilation to a specific target</h3><p id="-adzc8b_90">Compilation to a specific target works with multiple source sets. When Kotlin compiles a multiplatform project to a specific target, it collects all source sets labeled with this target and produces binaries from them.</p><p id="-adzc8b_91">Consider an example with <code class="code" id="-adzc8b_98">jvm</code>, <code class="code" id="-adzc8b_99">iosArm64</code>, and <code class="code" id="-adzc8b_100">js</code> targets. Kotlin creates the <code class="code" id="-adzc8b_101">commonMain</code> source set for common code and the corresponding <code class="code" id="-adzc8b_102">jvmMain</code>, <code class="code" id="-adzc8b_103">iosArm64Main</code>, and <code class="code" id="-adzc8b_104">jsMain</code> source sets for specific targets:</p><figure id="-adzc8b_92"><img alt="Compilation to a specific target" src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/specific-target-diagram.svg" title="Compilation to a specific target" width="700" height="289"></figure><p id="-adzc8b_93">During compilation to the JVM, Kotlin selects all source sets labeled with &quot;JVM&quot;, namely, <code class="code" id="-adzc8b_105">jvmMain</code> and <code class="code" id="-adzc8b_106">commonMain</code>. It then compiles them together to the JVM class files:</p><figure id="-adzc8b_94"><img alt="Compilation to JVM" src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/compilation-jvm-diagram.svg" title="Compilation to JVM" width="700" height="352"></figure><p id="-adzc8b_95">Because Kotlin compiles <code class="code" id="-adzc8b_107">commonMain</code> and <code class="code" id="-adzc8b_108">jvmMain</code> together, the resulting binaries contain declarations from both <code class="code" id="-adzc8b_109">commonMain</code> and <code class="code" id="-adzc8b_110">jvmMain</code>.</p><p id="-adzc8b_96">When working with multiplatform projects, remember:</p><ul class="list _bullet" id="-adzc8b_97"><li class="list__item" id="-adzc8b_111"><p id="-adzc8b_115">If you want Kotlin to compile your code to a specific platform, declare a corresponding target.</p></li><li class="list__item" id="-adzc8b_112"><p id="-adzc8b_116">To choose a directory or source file to store the code, first decide among which targets you want to share your code:</p><ul class="list _bullet" id="-adzc8b_117"><li class="list__item" id="-adzc8b_118"><p>If the code is shared among all targets, it should be declared in <code class="code" id="-adzc8b_120">commonMain</code>.</p></li><li class="list__item" id="-adzc8b_119"><p>If the code is used for only one target, it should be defined in a platform-specific source set for that target (for example, <code class="code" id="-adzc8b_121">jvmMain</code> for the JVM).</p></li></ul></li><li class="list__item" id="-adzc8b_113"><p id="-adzc8b_122">Code written in platform-specific source sets can access declarations from the common source set. For example, the code in <code class="code" id="-adzc8b_123">jvmMain</code> can use code from <code class="code" id="-adzc8b_124">commonMain</code>. However, the opposite isn't true: <code class="code" id="-adzc8b_125">commonMain</code> can't use code from <code class="code" id="-adzc8b_126">jvmMain</code>.</p></li><li class="list__item" id="-adzc8b_114"><p id="-adzc8b_127">Code written in platform-specific source sets can use the corresponding platform dependencies. For example, the code in <code class="code" id="-adzc8b_128">jvmMain</code> can use Java-only libraries, like <a href="https://github.com/google/guava" id="-adzc8b_129" data-external="true" rel="noopener noreferrer">Guava</a> or <a href="https://spring.io/" id="-adzc8b_130" data-external="true" rel="noopener noreferrer">Spring</a>.</p></li></ul></section><section class="chapter"><h3 id="intermediate-source-sets" data-toc="intermediate-source-sets">Intermediate source sets</h3><p id="-adzc8b_131">Simple multiplatform projects usually have only common and platform-specific code. The <code class="code" id="-adzc8b_149">commonMain</code> source set represents the common code shared among all declared targets. Platform-specific source sets, like <code class="code" id="-adzc8b_150">jvmMain</code>, represent platform-specific code compiled only to the respective target.</p><p id="-adzc8b_132">In practice, you often need more granular code sharing.</p><p id="-adzc8b_133">Consider an example where you need to target all modern Apple devices and Android devices:</p><div class="code-block" data-lang="kotlin">
kotlin {
    androidTarget()
    iosArm64()   // 64-bit iPhone devices
    macosArm64() // Modern Apple Silicon-based Macs
    watchosX64() // Modern 64-bit Apple Watch devices
    tvosArm64()  // Modern Apple TV devices  
}
</div><p id="-adzc8b_135">And you need a source set to add a function that generates a UUID for all Apple devices:</p><div class="code-block" data-lang="kotlin">
import platform.Foundation.NSUUID

fun randomUuidString(): String {
    // You want to access Apple-specific APIs
    return NSUUID().UUIDString()
}
</div><p id="-adzc8b_137">You can't add this function to <code class="code" id="-adzc8b_151">commonMain</code>. <code class="code" id="-adzc8b_152">commonMain</code> is compiled to all declared targets, including Android, but <code class="code" id="-adzc8b_153">platform.Foundation.NSUUID</code> is an Apple-specific API that's not available on Android. Kotlin shows an error if you try to reference <code class="code" id="-adzc8b_154">NSUUID</code> in <code class="code" id="-adzc8b_155">commonMain</code>.</p><p id="-adzc8b_138">You could copy and paste this code to each Apple-specific source set: <code class="code" id="-adzc8b_156">iosArm64Main</code>, <code class="code" id="-adzc8b_157">macosArm64Main</code>, <code class="code" id="-adzc8b_158">watchosX64Main</code>, and <code class="code" id="-adzc8b_159">tvosArm64Main</code>. But this approach is not recommended because duplicating code like this is prone to errors.</p><p id="-adzc8b_139">To solve this issue, you can use <span class="emphasis" id="-adzc8b_160">intermediate source sets</span>. An intermediate source set is a Kotlin source set that compiles to some, but not all of the targets in the project. You can also see intermediate source sets referred to as hierarchical source sets or simply hierarchies.</p><p id="-adzc8b_140">Kotlin creates some intermediate source sets by default. In this specific case, the resulting project structure will look like this:</p><figure id="-adzc8b_141"><img alt="Intermediate source sets" src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/intermediate-source-sets-diagram.svg" title="Intermediate source sets" width="700" height="394"></figure><p id="-adzc8b_142">Here, the multicolored blocks at the bottom are platform-specific source sets. Target labels are omitted for clarity.</p><p id="-adzc8b_143">The <code class="code" id="-adzc8b_161">appleMain</code> block is an intermediate source set created by Kotlin for sharing code compiled to Apple-specific targets. The <code class="code" id="-adzc8b_162">appleMain</code> source set compiles to only Apple targets. Therefore, Kotlin allows using Apple-specific APIs in <code class="code" id="-adzc8b_163">appleMain</code>, and you can add the <code class="code" id="-adzc8b_164">randomUUID()</code> function here.</p><aside class="prompt" data-type="tip" data-title="" id="-adzc8b_144"><p id="-adzc8b_165">See <a href="multiplatform-hierarchy.html" id="-adzc8b_166">Hierarchical project structure</a> to find all intermediate source sets that Kotlin creates and sets up by default and learn what you should do if Kotlin doesn't provide the intermediate source set you need by default.</p></aside><p id="-adzc8b_145">During compilation to a specific target, Kotlin gets all of the source sets, including intermediate source sets, labeled with this target. Therefore, all the code written in the <code class="code" id="-adzc8b_167">commonMain</code>, <code class="code" id="-adzc8b_168">appleMain</code>, and <code class="code" id="-adzc8b_169">iosArm64Main</code> source sets is combined during compilation to the <code class="code" id="-adzc8b_170">iosArm64</code> platform target:</p><figure id="-adzc8b_146"><img alt="Native executables" src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/multiplatform-executables-diagram.svg" title="Native executables" width="700" height="382"></figure><aside class="prompt" data-type="tip" data-title="" id="-adzc8b_147"><p id="-adzc8b_171">It's okay if some source sets don't have sources. For example, in iOS development, there's usually no need to provide code that is specific for iOS devices but not for iOS simulators. <code class="code" id="-adzc8b_172">iosArm64Main</code> is therefore rarely used.</p></aside><section class="chapter"><div class="collapse"><div class="collapse__title"><h4 id="apple-device-and-simulator-targets" data-toc="apple-device-and-simulator-targets">Apple device and simulator targets</h4></div><div class="collapse__content"><p id="-adzc8b_173">When you use Kotlin Multiplatform to develop iOS mobile applications, you usually work with the <code class="code" id="-adzc8b_178">iosMain</code> source set. While you might think it's a platform-specific source set for the <code class="code" id="-adzc8b_179">ios</code> target, there is no single <code class="code" id="-adzc8b_180">ios</code> target. Most mobile projects need at least two targets:</p><ul class="list _bullet" id="-adzc8b_174"><li class="list__item" id="-adzc8b_181"><p><span class="control" id="-adzc8b_183">Device target</span> is used to generate binaries that can be executed on iOS devices. There's currently only one device target for iOS: <code class="code" id="-adzc8b_184">iosArm64</code>.</p></li><li class="list__item" id="-adzc8b_182"><p><span class="control" id="-adzc8b_185">Simulator target</span> is used to generate binaries for the iOS simulator launched on your machine. If you have an Apple silicon Mac computer, choose <code class="code" id="-adzc8b_186">iosSimulatorArm64</code> as a simulator target. Use <code class="code" id="-adzc8b_187">iosX64</code> if you have an Intel-based Mac computer.</p></li></ul><p id="-adzc8b_175">If you declare only the <code class="code" id="-adzc8b_188">iosArm64</code> device target, you won't be able to run and debug your application and tests on your local machine.</p><p id="-adzc8b_176">Platform-specific source sets like <code class="code" id="-adzc8b_189">iosArm64Main</code>, <code class="code" id="-adzc8b_190">iosSimulatorArm64Main</code>, and <code class="code" id="-adzc8b_191">iosX64Main</code> are usually empty, as Kotlin code for iOS devices and simulators is normally the same. You can use only the <code class="code" id="-adzc8b_192">iosMain</code> intermediate source set to share code among all of them.</p><p id="-adzc8b_177">The same applies to other non-Mac Apple targets. For example, if you have the <code class="code" id="-adzc8b_193">tvosArm64</code> device target for Apple TV and the <code class="code" id="-adzc8b_194">tvosSimulatorArm64</code> and <code class="code" id="-adzc8b_195">tvosX64</code> simulator targets for Apple TV simulators on Apple silicon and Intel-based devices, respectively, you can use the <code class="code" id="-adzc8b_196">tvosMain</code> intermediate source set for all of them.</p></div></div></section></section></section><section class="chapter"><h2 id="integration-with-tests" data-toc="integration-with-tests">Integration with tests</h2><p id="-adzc8b_197">Real-life projects also require tests alongside the main production code. This is why all source sets created by default have the <code class="code" id="-adzc8b_202">Main</code> and <code class="code" id="-adzc8b_203">Test</code> suffixes. <code class="code" id="-adzc8b_204">Main</code> contains production code, while <code class="code" id="-adzc8b_205">Test</code> contains tests for this code. The connection between them is established automatically, and tests can use the API provided by the <code class="code" id="-adzc8b_206">Main</code> code without additional configuration.</p><p id="-adzc8b_198">The <code class="code" id="-adzc8b_207">Test</code> counterparts are also source sets similar to <code class="code" id="-adzc8b_208">Main</code>. For example, <code class="code" id="-adzc8b_209">commonTest</code> is a counterpart for <code class="code" id="-adzc8b_210">commonMain</code> and compiles to all of the declared targets, allowing you to write common tests. Platform-specific test source sets, such as <code class="code" id="-adzc8b_211">jvmTest</code>, are used to write platform-specific tests, for example, JVM-specific tests or tests that need JVM APIs.</p><p id="-adzc8b_199">Besides having a source set to write your common test, you also need a multiplatform testing framework. Kotlin provides a default <a href="https://kotlinlang.org/api/latest/kotlin.test/" id="-adzc8b_212" data-external="true" rel="noopener noreferrer"><code class="code" id="-adzc8b_216">kotlin.test</code></a> library that comes with the <code class="code" id="-adzc8b_213">@kotlin.Test</code> annotation and various assertion methods like <code class="code" id="-adzc8b_214">assertEquals</code> and <code class="code" id="-adzc8b_215">assertTrue</code>.</p><p id="-adzc8b_200">You can write platform-specific tests like regular tests for each platform in their respective source sets. Like with the main code, you can have platform-specific dependencies for each source set, such as <code class="code" id="-adzc8b_217">JUnit</code> for JVM and <code class="code" id="-adzc8b_218">XCTest</code> for iOS. To run tests for a particular target, use the <code class="code" id="-adzc8b_219">&lt;targetName&gt;Test</code> task.</p><p id="-adzc8b_201">Learn how to create and run multiplatform tests in the <a href="multiplatform-run-tests.html" id="-adzc8b_220">Test your multiplatform app tutorial</a>.</p></section><section class="chapter"><h2 id="what-s-next" data-toc="what-s-next">What's next?</h2><ul class="list _bullet" id="-adzc8b_221"><li class="list__item" id="-adzc8b_222"><p><a href="multiplatform-hierarchy.html" id="-adzc8b_225">Learn more about declaring and using predefined source sets in Gradle scripts</a></p></li><li class="list__item" id="-adzc8b_223"><p><a href="multiplatform-advanced-project-structure.html" id="-adzc8b_226">Explore advanced concepts of the multiplatform project structure</a></p></li><li class="list__item" id="-adzc8b_224"><p><a href="multiplatform-configure-compilations.html" id="-adzc8b_227">Learn more about target compilation and creating custom compilations</a></p></li></ul></section><div class="last-modified">Last modified: 16 May 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="create-kotlin-multiplatform-library.html" class="navigation-links__prev">Create your Kotlin Multiplatform library &ndash; tutorial</a><a href="multiplatform-advanced-project-structure.html" class="navigation-links__next">Advanced concepts of the multiplatform project structure</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b454/app.js"></script></body></html>