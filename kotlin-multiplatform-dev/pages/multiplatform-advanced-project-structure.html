<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2025-06-25T13:01:20.654980612"><meta name="build-number" content="637"><script>
    (function (w, d, s, l, i) {
        w[l] = w[l] || [];
        w[l].push({'gtm.start': new Date().getTime(), event: 'gtm.js'});
        var f = d.getElementsByTagName(s)[0], j = d.createElement(s), dl = l != 'dataLayer' ? '&amp;l=' + l : '';
        j.async = true;
        j.src = '//www.googletagmanager.com/gtm.js?id=' + i + dl;
        f.parentNode.insertBefore(j, f);
    })(window, document, 'script', 'dataLayer', 'GTM-5P98');
</script>
<script src="https://resources.jetbrains.com/storage/help-app/v6/analytics.js"></script>
<title>Advanced concepts of the multiplatform project structure | Kotlin Multiplatform Documentation</title><script type="application/json" id="virtual-toc-data">[{"id":"dependson-and-source-set-hierarchies","level":0,"title":"dependsOn and source set hierarchies","anchor":"#dependson-and-source-set-hierarchies"},{"id":"dependencies-on-other-libraries-or-projects","level":0,"title":"Dependencies on other libraries or projects","anchor":"#dependencies-on-other-libraries-or-projects"},{"id":"compilations","level":0,"title":"Compilations","anchor":"#compilations"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b454/app.css" rel="stylesheet"><link rel="manifest" href="https://www.jetbrains.com/site.webmanifest"><link rel="icon" type="image/x-icon" sizes="16x16" href="https://resources.jetbrains.com/storage/ui/favicons/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="https://resources.jetbrains.com/storage/ui/favicons/apple-touch-icon-57x57.png"><link rel="icon" type="image/png" sizes="96x96" href="https://resources.jetbrains.com/storage/ui/favicons/apple-touch-icon-60x60.png"><link rel="icon" type="image/png" sizes="300x300" href="https://resources.jetbrains.com/storage/ui/favicons/apple-touch-icon-72x72.png"><link rel="icon" type="image/png" sizes="500x500" href="https://resources.jetbrains.com/storage/ui/favicons/apple-touch-icon-76x76.png"><meta name="image" content="https://resources.jetbrains.com/storage/products/jetbrains/img/meta/preview.png"><!-- Open Graph --><meta property="og:title" content="Advanced concepts of the multiplatform project structure | Kotlin Multiplatform"><meta property="og:description" content=""><meta property="og:image" content="https://resources.jetbrains.com/storage/products/jetbrains/img/meta/preview.png"><meta property="og:site_name" content="Kotlin Multiplatform Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-advanced-project-structure.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@kotlin"><meta name="twitter:title" content="Advanced concepts of the multiplatform project structure | Kotlin Multiplatform"><meta name="twitter:description" content=""><meta name="twitter:creator" content="@kotlin"><meta name="twitter:image:src" content="https://resources.jetbrains.com/storage/products/jetbrains/img/meta/preview.png"><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-advanced-project-structure.html#webpage",
    "url": "https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-advanced-project-structure.html",
    "name": "Advanced concepts of the multiplatform project structure | Kotlin Multiplatform",
    "description": "",
    "image": "https://resources.jetbrains.com/storage/products/jetbrains/img/meta/preview.png",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "https://www.jetbrains.com/help/kotlin-multiplatform-dev/#website",
    "url": "https://www.jetbrains.com/help/kotlin-multiplatform-dev/",
    "name": "Kotlin Multiplatform Help"
}</script><!-- End Schema.org --><meta name="msapplication-TileColor" content="#000000"/>
<meta name="msapplication-TileImage"
      content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"/>
<meta name="msapplication-square70x70logo"
      content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"/>
<meta name="msapplication-square150x150logo"
      content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"/>
<meta name="msapplication-wide310x150logo"
      content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"/>
<meta name="msapplication-square310x310logo"
      content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"/>
<script>document.cookie="wh_theme=light;expires="+(new Date(Date.now()+500000000).toUTCString())+"; path=/;";</script>
<style>
<!--slack icon-->
[data-test="footer-socials"] [data-test="button"][title*="Kotlin Multiplatform Development Feed"]{position:relative;}
[data-test="footer-socials"] [data-test="button"][title*="Kotlin Multiplatform Development Feed"] svg{visibility:hidden;}
[data-test="footer-socials"] [data-test="button"][title*="Kotlin Multiplatform Development Feed"]::before{
display:block;content:"";position:absolute;top:0;bottom:0;left:0;right:0;
background:url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="%23fff"><path d="M9.586 6.601h1.9v-1.9a1.837 1.837 0 00-1.9-1.9 1.9 1.9 0 000 3.8zm1.9 7.6v4.7a1.837 1.837 0 01-1.9 1.9 1.9 1.9 0 01-1.9-1.9v-4.7a1.899 1.899 0 011.9-1.9 1.837 1.837 0 011.9 1.9zm-5.864 1.773a1.839 1.839 0 01-.737.127 1.9 1.9 0 010-3.8h1.9v1.9a1.839 1.839 0 01-1.163 1.773zm3.963-4.673h-4.7a1.9 1.9 0 010-3.8h4.7a1.838 1.838 0 011.9 1.9 1.9 1.9 0 01-1.9 1.9zm11.4-1.9a1.967 1.967 0 00-1.9-1.9 1.899 1.899 0 00-1.9 1.9v1.9h1.9a1.9 1.9 0 001.9-1.9zm-5.862 1.773a1.839 1.839 0 01-.738.127 1.9 1.9 0 01-1.9-1.9v-4.7a1.839 1.839 0 011.9-1.9 1.898 1.898 0 011.9 1.9v4.7a1.837 1.837 0 01-1.162 1.773zm-.738 9.628a1.839 1.839 0 001.9-1.9 1.9 1.9 0 00-1.9-1.9h-1.9v1.9a1.899 1.899 0 001.9 1.9zm4.7-4.7h-4.7a1.9 1.9 0 110-3.8h4.7a1.836 1.836 0 011.9 1.9 1.9 1.9 0 01-1.9 1.9z"/></svg>') no-repeat center;background-size:20px 20px;}
[data-test="footer-socials"]+.jb-footer__legal{flex-basis:100%;margin-top:8px;}

<!--Drop any switches and set default theme-->
.wh-header__switchers{display:none!important}
</style></head><body data-id="multiplatform-advanced-project-structure" data-main-title="Advanced concepts of the multiplatform project structure" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Explore project structure" data-edit-url="https://github.com/JetBrains/kotlin-multiplatform-dev-docs/edit/master/topics/development/multiplatform-advanced-project-structure.md"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Kotlin Multiplatform  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="multiplatform-advanced-project-structure" id="multiplatform-advanced-project-structure.md">Advanced concepts of the multiplatform project structure</h1><p id="-whuei2_2">This article explains advanced concepts of the Kotlin Multiplatform project structure and how they map to the Gradle implementation. This information will be useful if you need to work with low-level abstractions of the Gradle build (configurations, tasks, publications, and others) or are creating a Gradle plugin for Kotlin Multiplatform builds.</p><p id="-whuei2_3">This page can be useful if you:</p><ul class="list _bullet" id="-whuei2_4"><li class="list__item" id="-whuei2_11"><p>Need to share code among a set of targets for which Kotlin doesn't create a source set.</p></li><li class="list__item" id="-whuei2_12"><p>Want to create a Gradle plugin for Kotlin Multiplatform builds, or need to work with low-level abstractions of the Gradle build, such as configurations, tasks, publications, and others.</p></li></ul><p id="-whuei2_5">One of the crucial things to understand about dependency management in a multiplatform project is the difference between Gradle-style project or library dependencies and the <code class="code" id="-whuei2_13">dependsOn</code> relation between source sets that is specific to Kotlin:</p><ul class="list _bullet" id="-whuei2_6"><li class="list__item" id="-whuei2_14"><p><code class="code" id="-whuei2_16">dependsOn</code> is a relation between common and platform-specific source sets that enables <a href="#dependson-and-source-set-hierarchies" id="-whuei2_17">source set hierarchy</a> and sharing code in multiplatform projects in general. For default source sets the hierarchy is managed automatically, but you may need to alter it in specific circumstances.</p></li><li class="list__item" id="-whuei2_15"><p>Library and project dependencies in general work as usual, but to properly manage them in a multiplatform project you should understand <a href="#dependencies-on-other-libraries-or-projects" id="-whuei2_18">how Gradle dependencies are resolved</a> into granular <span class="control" id="-whuei2_19">source set &rarr; source set</span> dependencies used for compilation.</p></li></ul><aside class="prompt" data-type="tip" data-title="" id="-whuei2_7"><p id="-whuei2_20">Before diving into advanced concepts, we recommend learning <a href="multiplatform-discover-project.html" id="-whuei2_21">the basics of the multiplatform project structure</a>.</p></aside><section class="chapter"><h2 id="dependson-and-source-set-hierarchies" data-toc="dependson-and-source-set-hierarchies">dependsOn and source set hierarchies</h2><p id="-whuei2_22">Usually, you'll be working with <span class="emphasis" id="-whuei2_35">dependencies</span> and not with the <span class="emphasis" id="-whuei2_36"><code class="code" id="-whuei2_38">dependsOn</code></span> relation. However, examining <code class="code" id="-whuei2_37">dependsOn</code> is crucial to understanding how Kotlin Multiplatform projects work under the hood.</p><p id="-whuei2_23"><code class="code" id="-whuei2_39">dependsOn</code> is a Kotlin-specific relation between two Kotlin source sets. This could be a connection between common and platform-specific source sets, for example, when the <code class="code" id="-whuei2_40">jvmMain</code> source set depends on <code class="code" id="-whuei2_41">commonMain</code>, <code class="code" id="-whuei2_42">iosArm64Main</code> depends on <code class="code" id="-whuei2_43">iosMain</code>, and so on.</p><p id="-whuei2_24">Consider a general example with Kotlin source sets <code class="code" id="-whuei2_44">A</code> and <code class="code" id="-whuei2_45">B</code>. The expression <code class="code" id="-whuei2_46">A.dependsOn(B)</code> instructs Kotlin that:</p><ol class="list _decimal" id="-whuei2_25" type="1"><li class="list__item" id="-whuei2_47"><p><code class="code" id="-whuei2_51">A</code> observes the API from <code class="code" id="-whuei2_52">B</code>, including internal declarations.</p></li><li class="list__item" id="-whuei2_48"><p><code class="code" id="-whuei2_53">A</code> can provide actual implementations for expected declarations from <code class="code" id="-whuei2_54">B</code>. This is a necessary and sufficient condition, as <code class="code" id="-whuei2_55">A</code> can provide <code class="code" id="-whuei2_56">actuals</code> for <code class="code" id="-whuei2_57">B</code> if and only if <code class="code" id="-whuei2_58">A.dependsOn(B)</code> either directly or indirectly.</p></li><li class="list__item" id="-whuei2_49"><p><code class="code" id="-whuei2_59">B</code> should compile to all the targets that <code class="code" id="-whuei2_60">A</code> compiles to, in addition to its own targets.</p></li><li class="list__item" id="-whuei2_50"><p><code class="code" id="-whuei2_61">A</code> inherits all the regular dependencies of <code class="code" id="-whuei2_62">B</code>.</p></li></ol><p id="-whuei2_26">The <code class="code" id="-whuei2_63">dependsOn</code> relation creates a tree-like structure known as a source set hierarchy. Here's an example of a typical project for mobile development with <code class="code" id="-whuei2_64">androidTarget</code>, <code class="code" id="-whuei2_65">iosArm64</code> (iPhone devices), and <code class="code" id="-whuei2_66">iosSimulatorArm64</code> (iPhone simulator for Apple Silicon Mac):</p><figure id="-whuei2_27"><img alt="DependsOn tree structure" src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/dependson-tree-diagram.svg" title="DependsOn tree structure" width="700" height="401"></figure><p id="-whuei2_28">Arrows represent <code class="code" id="-whuei2_67">dependsOn</code> relations. These relations are preserved during the compilation of platform binaries. This is how Kotlin understands that <code class="code" id="-whuei2_68">iosMain</code> is supposed to see the API from <code class="code" id="-whuei2_69">commonMain</code> but not from <code class="code" id="-whuei2_70">iosArm64Main</code>:</p><figure id="-whuei2_29"><img alt="DependsOn relations during compilation" src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/dependson-relations-diagram.svg" title="DependsOn relations during compilation" width="700" height="431"></figure><p id="-whuei2_30"><code class="code" id="-whuei2_71">dependsOn</code> relations are configured with the <code class="code" id="-whuei2_72">KotlinSourceSet.dependsOn(KotlinSourceSet)</code> call, for example:</p><div class="code-block" data-lang="kotlin">
kotlin {
    // Targets declaration
    sourceSets {
        // Example of configuring the dependsOn relation 
        iosArm64Main.dependsOn(commonMain)
    }
}
</div><ul class="list _bullet" id="-whuei2_32"><li class="list__item" id="-whuei2_73"><p>This example shows how <code class="code" id="-whuei2_75">dependsOn</code> relations can be defined in the build script. However, the Kotlin Gradle plugin creates source sets and sets up these relations by default, so you don't need to do so manually.</p></li><li class="list__item" id="-whuei2_74"><p><code class="code" id="-whuei2_76">dependsOn</code> relations are declared separately from the <code class="code" id="-whuei2_77">dependencies {}</code> block in build scripts. This is because <code class="code" id="-whuei2_78">dependsOn</code> is not a regular dependency; instead, it is a specific relation between Kotlin source sets necessary for sharing code across different targets.</p></li></ul><p id="-whuei2_33">You cannot use <code class="code" id="-whuei2_79">dependsOn</code> to declare regular dependencies on a published library or another Gradle project. For example, you can't set up <code class="code" id="-whuei2_80">commonMain</code> to depend on the <code class="code" id="-whuei2_81">commonMain</code> of the <code class="code" id="-whuei2_82">kotlinx-coroutines-core</code> library or call <code class="code" id="-whuei2_83">commonTest.dependsOn(commonMain)</code>.</p><section class="chapter"><h3 id="declaring-custom-source-sets" data-toc="declaring-custom-source-sets">Declaring custom source sets</h3><p id="-whuei2_84">In some cases, you might need to have a custom intermediate source set in your project. Consider a project that compiles to the JVM, JS, and Linux, and you want to share some sources only between the JVM and JS. In this case, you should find a specific source set for this pair of targets, as described in <a href="multiplatform-discover-project.html" id="-whuei2_95">The basics of multiplatform project structure</a>.</p><p id="-whuei2_85">Kotlin doesn't create such a source set automatically. This means you should create it manually with the <code class="code" id="-whuei2_96">by creating</code> construction:</p><div class="code-block" data-lang="kotlin">
kotlin {
    jvm()
    js()
    linuxX64()

    sourceSets {
        // Create a source set named &quot;jvmAndJs&quot;
        val jvmAndJsMain by creating {
            // …
        }
    }
}
</div><p id="-whuei2_87">However, Kotlin still doesn't know how to treat or compile this source set. If you drew a diagram, this source set would be isolated and wouldn't have any target labels:</p><figure id="-whuei2_88"><img alt="Missing dependsOn relation" src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/missing-dependson-diagram.svg" title="Missing dependsOn relation" width="700" height="375"></figure><p id="-whuei2_89">To fix this, include <code class="code" id="-whuei2_97">jvmAndJsMain</code> in the hierarchy by adding several <code class="code" id="-whuei2_98">dependsOn</code> relations:</p><div class="code-block" data-lang="kotlin">
kotlin {
    jvm()
    js()
    linuxX64()

    sourceSets {
        val jvmAndJsMain by creating {
            // Don't forget to add dependsOn to commonMain
            dependsOn(commonMain.get())
        }

        jvmMain {
            dependsOn(jvmAndJsMain)
        }

        jsMain {
            dependsOn(jvmAndJsMain)
        }
    }
}
</div><p id="-whuei2_91">Here, <code class="code" id="-whuei2_99">jvmMain.dependsOn(jvmAndJsMain)</code> adds the JVM target to <code class="code" id="-whuei2_100">jvmAndJsMain</code>, and <code class="code" id="-whuei2_101">jsMain.dependsOn(jvmAndJsMain)</code> adds the JS target to <code class="code" id="-whuei2_102">jvmAndJsMain</code>.</p><p id="-whuei2_92">The final project structure will look like this:</p><figure id="-whuei2_93"><img alt="Final project structure" src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/final-structure-diagram.svg" title="Final project structure" width="700" height="376"></figure><aside class="prompt" data-type="note" data-title="" id="-whuei2_94"><p id="-whuei2_103">Manual configuration of <code class="code" id="-whuei2_104">dependsOn</code> relations disables automatic application of the default hierarchy template. See <a href="multiplatform-hierarchy.html#additional-configuration" id="-whuei2_105">Additional configuration</a> to learn more about such cases and how to handle them.</p></aside></section></section><section class="chapter"><h2 id="dependencies-on-other-libraries-or-projects" data-toc="dependencies-on-other-libraries-or-projects">Dependencies on other libraries or projects</h2><p id="-whuei2_106">In multiplatform projects, you can set up regular dependencies either on a published library or on another Gradle project.</p><p id="-whuei2_107">Kotlin Multiplatform generally declares dependencies in a typical Gradle way. Similarly to Gradle, you:</p><ul class="list _bullet" id="-whuei2_108"><li class="list__item" id="-whuei2_116"><p>Use the <code class="code" id="-whuei2_119">dependencies {}</code> block in your build script.</p></li><li class="list__item" id="-whuei2_117"><p>Choose the proper scope for the dependencies, for example, <code class="code" id="-whuei2_120">implementation</code> or <code class="code" id="-whuei2_121">api</code>.</p></li><li class="list__item" id="-whuei2_118"><p>Reference the dependency either by specifying its coordinates if it's published in a repo, like <code class="code" id="-whuei2_122">&quot;com.google.guava:guava:32.1.2-jre&quot;</code>, or its path if it's a Gradle project in the same build, like <code class="code" id="-whuei2_123">project(&quot;:utils:concurrency&quot;)</code>.</p></li></ul><p id="-whuei2_109">Dependency configuration in multiplatform projects has some special features. Each Kotlin source set has its own <code class="code" id="-whuei2_124">dependencies {}</code> block. This allows you to declare platform-specific dependencies in platform-specific source sets:</p><div class="code-block" data-lang="kotlin">
kotlin {
    // Targets declaration
    sourceSets {
        jvmMain.dependencies {
            // This is jvmMain's dependencies, so it's OK to add a JVM-specific dependency
            implementation(&quot;com.google.guava:guava:32.1.2-jre&quot;)
        }
    }
}
</div><p id="-whuei2_111">Common dependencies are trickier. Consider a multiplatform project that declares a dependency on a multiplatform library, for example, <code class="code" id="-whuei2_125">kotlinx.coroutines</code>:</p><div class="code-block" data-lang="kotlin">
kotlin {
    androidTarget()     // Android
    iosArm64()          // iPhone devices 
    iosSimulatorArm64() // iPhone simulator on Apple Silicon Mac

    sourceSets {
        commonMain.dependencies {
            implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.3&quot;)
        }
    }
}
</div><p id="-whuei2_113">There are three important concepts in dependency resolution:</p><ol class="list _decimal" id="-whuei2_114" type="1"><li class="list__item" id="-whuei2_126"><p id="-whuei2_129">Multiplatform dependencies are propagated down the <code class="code" id="-whuei2_133">dependsOn</code> structure. When you add a dependency to <code class="code" id="-whuei2_134">commonMain</code>, it will be automatically added to all source sets that declare <code class="code" id="-whuei2_135">dependsOn</code> relations directly or indirectly in <code class="code" id="-whuei2_136">commonMain</code>.</p><p id="-whuei2_130">In this case, the dependency was indeed automatically added to all the <code class="code" id="-whuei2_137">*Main</code> source sets: <code class="code" id="-whuei2_138">iosMain</code>, <code class="code" id="-whuei2_139">jvmMain</code>, <code class="code" id="-whuei2_140">iosSimulatorArm64Main</code>, and <code class="code" id="-whuei2_141">iosX64Main</code>. All these source sets inherit the <code class="code" id="-whuei2_142">kotlin-coroutines-core</code> dependency from the <code class="code" id="-whuei2_143">commonMain</code> source set, so you don't have to copy and paste it in all of them manually:</p><figure id="-whuei2_131"><img alt="Propagation of multiplatform dependencies" src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/dependency-propagation-diagram.svg" title="Propagation of multiplatform dependencies" width="700" height="365"></figure><aside class="prompt" data-type="tip" data-title="" id="-whuei2_132"><p id="-whuei2_144">The propagation mechanism allows you to choose a scope that will receive the declared dependency by selecting a specific source set. For example, if you want to use <code class="code" id="-whuei2_145">kotlinx.coroutines</code> on iOS but not on Android, you can add this dependency to <code class="code" id="-whuei2_146">iosMain</code> only.</p></aside></li><li class="list__item" id="-whuei2_127"><p id="-whuei2_147">The <span class="emphasis" id="-whuei2_151">source set &rarr; multiplatform library</span> dependencies, like <code class="code" id="-whuei2_152">commonMain</code> to <code class="code" id="-whuei2_153">org.jetbrians.kotlinx:kotlinx-coroutines-core:1.7.3</code> above, represent the intermediate state of dependency resolution. The final state of resolution is always represented by the <span class="emphasis" id="-whuei2_154">source set &rarr; source set</span> dependencies.</p><aside class="prompt" data-type="note" data-title="" id="-whuei2_148"><p id="-whuei2_155">The final <span class="emphasis" id="-whuei2_156">source set &rarr; source set</span> dependencies are not <code class="code" id="-whuei2_157">dependsOn</code> relations.</p></aside><p id="-whuei2_149">To infer granular <span class="emphasis" id="-whuei2_158">source set &rarr; source set</span> dependencies, Kotlin reads the source set structure that is published alongside each multiplatform library. After this step, each library will be represented internally not as a whole, but as a collection of its source sets. See this example for <code class="code" id="-whuei2_159">kotlinx-coroutines-core</code>:</p><figure id="-whuei2_150"><img alt="Serialization of the source set structure" src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/structure-serialization-diagram.svg" title="Serialization of the source set structure" width="700" height="282"></figure></li><li class="list__item" id="-whuei2_128"><p id="-whuei2_160">Kotlin takes each dependency relation and resolves it to a collection of source sets from a dependency. Each dependency source set in that collection must have <span class="emphasis" id="-whuei2_166">compatible targets</span>. A dependency source set has compatible targets if it compiles to <span class="emphasis" id="-whuei2_167">at least the same targets</span> as the consumer source set.</p><p id="-whuei2_161">Consider an example where <code class="code" id="-whuei2_168">commonMain</code> in the sample project compiles to <code class="code" id="-whuei2_169">androidTarget</code>, <code class="code" id="-whuei2_170">iosX64</code>, and <code class="code" id="-whuei2_171">iosSimulatorArm64</code>:</p><ul class="list _bullet" id="-whuei2_162"><li class="list__item" id="-whuei2_172"><p>First, it resolves a dependency on <code class="code" id="-whuei2_174">kotlinx-coroutines-core.commonMain</code>. This happens because <code class="code" id="-whuei2_175">kotlinx-coroutines-core</code> compiles to all possible Kotlin targets. Therefore, its <code class="code" id="-whuei2_176">commonMain</code> compiles to all possible targets, including the required <code class="code" id="-whuei2_177">androidTarget</code>, <code class="code" id="-whuei2_178">iosX64</code>, and <code class="code" id="-whuei2_179">iosSimulatorArm64</code>.</p></li><li class="list__item" id="-whuei2_173"><p>Second, <code class="code" id="-whuei2_180">commonMain</code> depends on <code class="code" id="-whuei2_181">kotlinx-coroutines-core.concurrentMain</code>. Since <code class="code" id="-whuei2_182">concurrentMain</code> in <code class="code" id="-whuei2_183">kotlinx-coroutines-core</code> compiles to all the targets except for JS, it matches the targets of the consumer project's <code class="code" id="-whuei2_184">commonMain</code>.</p></li></ul><p id="-whuei2_163">However, source sets like <code class="code" id="-whuei2_185">iosX64Main</code> from coroutines are incompatible with the consumer's <code class="code" id="-whuei2_186">commonMain</code>. Even though <code class="code" id="-whuei2_187">iosX64Main</code> compiles to one of the targets of <code class="code" id="-whuei2_188">commonMain</code>, namely, <code class="code" id="-whuei2_189">iosX64</code>, it doesn't compile either to <code class="code" id="-whuei2_190">androidTarget</code> or to <code class="code" id="-whuei2_191">iosSimulatorArm64</code>.</p><p id="-whuei2_164">The results of the dependency resolution directly affect which of the code in <code class="code" id="-whuei2_192">kotlinx-coroutines-core</code> is visible:</p><figure id="-whuei2_165"><img alt="Error on JVM-specific API in common code" src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/dependency-resolution-error.png" title="Error on JVM-specific API in common code" width="700" height="368"></figure></li></ol><section class="chapter"><h3 id="aligning-versions-of-common-dependencies-across-source-sets" data-toc="aligning-versions-of-common-dependencies-across-source-sets">Aligning versions of common dependencies across source sets</h3><p id="-whuei2_193">In Kotlin Multiplatform projects, the common source set is compiled several times to produce a klib and as a part of each configured <a href="multiplatform-configure-compilations.html" id="-whuei2_200">compilation</a>. To produce consistent binaries, common code should be compiled against the same versions of multiplatform dependencies each time. The Kotlin Gradle plugin helps align these dependencies, ensuring the effective dependency version is the same for each source set.</p><p id="-whuei2_194">In the example above, imagine that you want to add the <code class="code" id="-whuei2_201">androidx.navigation:navigation-compose:2.7.7</code> dependency to your <code class="code" id="-whuei2_202">androidMain</code> source set. Your project explicitly declares the <code class="code" id="-whuei2_203">kotlinx-coroutines-core:1.7.3</code> dependency for the <code class="code" id="-whuei2_204">commonMain</code> source set, but the Compose Navigation library with the version 2.7.7 requires Kotlin coroutines 1.8.0 or newer.</p><p id="-whuei2_195">Since <code class="code" id="-whuei2_205">commonMain</code> and <code class="code" id="-whuei2_206">androidMain</code> are compiled together, the Kotlin Gradle plugin chooses between the two versions of the coroutines library and applies <code class="code" id="-whuei2_207">kotlinx-coroutines-core:1.8.0</code> to the <code class="code" id="-whuei2_208">commonMain</code> source set. But to make the common code compile consistently across all configured targets, iOS source sets also need to be constrained to the same dependency version. So Gradle propagates the <code class="code" id="-whuei2_209">kotlinx.coroutines-*:1.8.0</code> dependency to the <code class="code" id="-whuei2_210">iosMain</code> source set as well.</p><figure id="-whuei2_196"><img alt="Alignment of dependencies among *Main source sets" src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/multiplatform-source-set-dependency-alignment.svg" title="Alignment of dependencies among *Main source sets" width="700" height="391"></figure><p id="-whuei2_197">Dependencies are aligned separately across the <code class="code" id="-whuei2_211">*Main</code> source sets and the <a href="multiplatform-discover-project.html#integration-with-tests" id="-whuei2_212"><code class="code" id="-whuei2_215">*Test</code> source sets</a>. The Gradle configuration for <code class="code" id="-whuei2_213">*Test</code> source sets includes all dependencies of <code class="code" id="-whuei2_214">*Main</code> source sets, but not vice versa. So you can test your project with newer library versions without affecting your main code.</p><p id="-whuei2_198">For example, you have the Kotlin coroutines 1.7.3 dependency in your <code class="code" id="-whuei2_216">*Main</code> source sets, propagated to every source set in the project. However, in the <code class="code" id="-whuei2_217">iosTest</code> source set, you decide to upgrade the version to 1.8.0 to test out the new library release. According to the same algorithm, this dependency is going to be propagated throughout the tree of <code class="code" id="-whuei2_218">*Test</code> source sets, so every <code class="code" id="-whuei2_219">*Test</code> source set will be compiled with the <code class="code" id="-whuei2_220">kotlinx.coroutines-*:1.8.0</code> dependency.</p><figure id="-whuei2_199"><img alt="Test source sets resolving dependencies separately from the main source sets" src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/test-main-source-set-dependency-alignment.svg" title="Test source sets resolving dependencies separately from the main source sets" width="706" height="444"></figure></section></section><section class="chapter"><h2 id="compilations" data-toc="compilations">Compilations</h2><p id="-whuei2_221">Contrary to single-platform projects, Kotlin Multiplatform projects require multiple compiler launches to build all the artifacts. Each compiler launch is a <span class="emphasis" id="-whuei2_227">Kotlin compilation</span>.</p><p id="-whuei2_222">For example, here's how binaries for iPhone devices are generate during this Kotlin compilation mentioned earlier:</p><figure id="-whuei2_223"><img alt="Kotlin compilation for iOS" src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/ios-compilation-diagram.svg" title="Kotlin compilation for iOS" width="700" height="446"></figure><p id="-whuei2_224">Kotlin compilations are grouped under targets. By default, Kotlin creates two compilations for each target, the <code class="code" id="-whuei2_228">main</code> compilation for production sources and the <code class="code" id="-whuei2_229">test</code> compilation for test sources.</p><p id="-whuei2_225">Compilations in build scripts are accessed in a similar manner. You first select a Kotlin target, then access the <code class="code" id="-whuei2_230">compilations</code> container inside, and finally choose the necessary compilation by its name:</p><div class="code-block" data-lang="kotlin">
kotlin {
    // Declare and configure the JVM target
    jvm {
        val mainCompilation: KotlinJvmCompilation = compilations.getByName(&quot;main&quot;)
    }
}
</div></section><div class="last-modified">Last modified: 16 May 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="multiplatform-discover-project.html" class="navigation-links__prev">The basics of Kotlin Multiplatform project structure</a><a href="multiplatform-project-configuration.html" class="navigation-links__next">Choosing a configuration for your Kotlin Multiplatform project</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b454/app.js"></script></body></html>