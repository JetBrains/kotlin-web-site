[//]: # (title: Compatibility guide for Kotlin Multiplatform)

This guide summarizes [incompatible changes](kotlin-evolution.md#incompatible-changes) you might encounter while
developing projects with Kotlin Multiplatform.

> Mind the deprecation cycle of a specific change in relation to the Kotlin version you have in your projects. The current
> Stable version of Kotlin is %kotlinVersion%.
> 
{type="note"}

## New approach to auto-generated targets

**What's changed?**

Target accessors auto-generated by Gradle are no longer available inside the `kotlin.targets` block. Use
the `findByName("targetName")` method instead.

Note that such accessors are still available in the `kotlin.targets` case, for example, `kotlin.targets.linuxX64`.

**What's the best practice now?**

<table header-style="top">
    <tr>
        <td>Before</td>
        <td>Now</td>
    </tr>
    <tr>
<td>

```kotlin
kotlin {
    targets {
        configure(['windows',
            'linux']) {
        }
    }
}
```

</td>
<td>

```kotlin
kotlin {
    targets {
        configure([findByName('windows'),
            findByName('linux')]) {
        }
    }
}
```

</td>
    </tr>
</table>

**When do the changes take effect?**

In Kotlin 1.7.20, an error is introduced when using target accessors in the `kotlin.targets` block.

For more information, see the [corresponding issue in YouTrack](https://youtrack.jetbrains.com/issue/KT-47047).

## Changes in Gradle input and output compile tasks

**What's changed?**

Kotlin compile tasks no longer inherit the Gradle `AbstractCompile` task that has the `sourceCompatibility` and
`targetCompatibility` inputs, making them unavailable in Kotlin users' scripts.

Other breaking changes in compile tasks:

**What's the best practice now?**

| Before                                                              | Now                                                                                                            |
|---------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------|
| The `SourceTask.stableSources` input is no longer available.        | Use the `sources` input instead. Also, the `setSource()` methods are still available.                          |
| The `sourceFilesExtensions` input was removed.                      | Compile tasks still implement the `PatternFilterable` interface. Use its methods for filtering Kotlin sources. |
| The `Gradle destinationDir: File` output was deprecated.            | Use the `destinationDirectory: DirectoryProperty` output instead.                                              |
| The `classpath` property of the `KotlinCompile` task is deprecated. | All compile tasks now use the `libraries` input for a list of libraries required for compilation.              |

**When do the changes take effect?**

In Kotlin 1.7.20, inputs are not available, the output is replaced, and the `classpath` property is deprecated.

For more information, see the [corresponding issue in YouTrack](https://youtrack.jetbrains.com/issue/KT-32805).

## New configuration names for dependencies on the compilation

**What's changed?**

Compilation configurations created by the Kotlin Multiplatform Gradle Plugin received new names.

A target in the Kotlin Multiplatform project has two default compilations, `main` and `test`. Each of these compilations
has its own default source set, for example, `jvmMain` and `jvmTest`. Previously the configuration names for the test
compilation and its default source set were the same, which might lead to a name clash resulting in issues when a
configuration marked with platform-specific attributes is included in another configuration.

Now compilation configurations have an extra `Compilation` postfix, while projects and plugins that use old hard-coded
configuration names no longer compile.

Configuration names for dependencies on the corresponding source set stay the same.

**What's the best practice now?**

<table header-style="top">
    <tr>
        <td></td>
        <td>Before</td>
        <td>Now</td>
    </tr>
    <tr>
        <td rowspan="2">Dependencies of the <code>jvmMain</code> compilation</td>
<td>

```kotlin
jvm<Scope>
```

</td>
<td>

```kotlin
jvmCompilation<Scope>
```

</td>
    </tr>
    <tr>
<td>

```kotlin
dependencies {
    add("jvmImplementation",
        "foo.bar.baz:1.2.3")
}
```

</td>
<td>

```kotlin
dependencies {
    add("jvmCompilationImplementation",
        "foo.bar.baz:1.2.3")
}
```

</td>
    </tr>
    <tr>
        <td>Dependencies of the <code>jvmMain</code> source set</td>
<td colspan="2">

```kotlin
jvmMain<Scope>
```

</td>
    </tr>
    <tr>
        <td>Dependencies of the <code>jvmTest</code> compilation</td>
<td>

```kotlin
jvmTest<Scope>
```

</td>
<td>

```kotlin
jvmTestCompilation<Scope>
```

</td>
    </tr>
    <tr>
        <td>Dependencies of the <code>jvmTest</code> source set</td>
<td colspan="2">

```kotlin
jvmTest<Scope>
```

</td>
    </tr>
</table>

The available scopes are `Api`, `Implementation`, `CompileOnly`, and `RuntimeOnly`.

**When do the changes take effect?**

In Kotlin 1.8.0, an error is introduced when using old configuration names in hard-coded strings.

For more information, see the [corresponding issue in YouTrack](https://youtrack.jetbrains.com/issue/KT-35916/).

<anchor name="deprecate-hmpp-properties"></anchor>

## Deprecated Gradle properties for hierarchical structure support

**What's changed?**

Throughout its evolution, Kotlin was gradually introducing the support for [hierarchical structure](multiplatform-hierarchy.md),
in multiplatform projects, an ability to have intermediate source sets between the common source set `commonMain` and
any platform-specific one, for example, `jvmMain`.

For the transition period, while the toolchain wasn't stable enough, a couple of Gradle properties were introduced,
allowing granular opt-ins and opt-outs.

Since Kotlin 1.6.20, the hierarchical project structure support has been enabled by default. However, these properties
were kept for opting out in case of blocking issues. After processing all the feedback, we're now starting to phase out
those properties completely.

The following properties are now deprecated and will be removed in Kotlin 1.9.20:

* `kotlin.internal.mpp.hierarchicalStructureByDefault`
* `kotlin.mpp.enableCompatibilityMetadataVariant`
* `kotlin.mpp.hierarchicalStructureSupport`
* `kotlin.mpp.enableGranularSourceSetsMetadata`
* `kotlin.native.enableDependencyPropagation`

**What's the best practice now?**

* Remove these properties from your `gradle.properties` and `local.properties` files.
* Avoid setting them programmatically in the Gradle build scripts or your Gradle plugins.
* In case deprecated properties are set by some third-party Gradle plugin used in your build, ask the plugin maintainers
not to set these properties.

As the default behavior of the Kotlin toolchain doesn't include such properties since 1.6.20, we don't expect
any serious impact from removing them. Most possible consequences will be visible immediately after the project rebuild.

If you're a library author and want to be extra safe, check that consumers can work with your library.

**When do the changes take effect?**

In 1.8.20, the Kotlin Gradle plugin shows a warning if the build sets these properties. Starting with Kotlin 1.9.0,
the properties are silently ignored.

In the unlikely case you face some problems after removing these properties, create an [issue in YouTrack](https://kotl.in/issue).

<anchor name="deprecate-pre-hmpp-dependencies"></anchor>
## Deprecated support of multiplatform libraries published in a legacy mode

**What's changed?**

[Previously](#deprecated-gradle-properties-for-hierarchical-structure-support), Kotlin Multiplatform deprecated 
a legacy mode of Multiplatform Projects support, encouraging everyone to migrate to the so-called "hierarchical support" mode,
thus preventing "legacy" binaries from being published. 

In Kotlin 1.9.20 we're continuing to phase out "legacy" binaries from the ecosystem, now preventing the use "usage" of
the "legacy" libraries. If your project uses a dependency that was published in a legacy mode, the following warning
will be issued:

```
The dependency group:artifact:1.0 was published in the legacy mode. Support for such dependencies will be removed in the future
```

**What's the best practice now?**

_If you're a consumer of libraries_: most of the libraries already migrated to the "hierarchical support" mode, so chances are high you just have to bump
the used version. Please refer to the documentation of a respective library for details.   

If the library doesn't publish non-legacy binaries yet, you're encouraged to reach the maintainers and point them to the present document.

_If you're a library author_: update to the latest Kotlin Gradle Plugin and ensure you've fixed deprecations outlined 
in the previous [section](#deprecated-gradle-properties-for-hierarchical-structure-support) sections. Kotlin Team is eager
to help the ecosystem migrate, so if you face any issues, don't hesitate to create an [issue in YouTrack](https://kotl.in/issue).

**When do the changes take effect?**

* Kotlin 1.9.0: warning on using legacy dependencies
* Kotlin 1.9.20: error on using legacy dependencies
* Kotlin >1.9.20: support for legacy dependencies is dropped, depending on such libraries might cause build failures

<anchor name="compilation-source-deprecation"></anchor>
## Deprecated API for adding Kotlin Source Sets to Kotlin Compilation directly

**What's changed?**

Access to `KotlinCompilation.source` has been deprecated. Code like this will provoke a deprecation warning:

```kotlin
kotlin {
    jvm()
    js()
    ios()
    
    sourceSets {
        val commonMain by getting 
        val myCustomIntermediateSourceSet by creating {
            dependsOn(commonMain)
        }
        
        targets["jvm"].compilations["main"].source(myCustomIntermediateSourceSet)
    }
}
```

**What's the best practice now?**

For all intents and purposes, `KotlinCompilation.source(someSourceSet)` is equivalent to adding a `dependsOn` to 
`someSourceSet` from the default source set of the `KotlinCompilation`. In the general case, the replacement is 
`KotlinCompilation.defaultSourceSet.dependsOn(someSourceSet)`, but often it is more readable to refer to that source set
directly via `by getting`.

Example with the code above:

```kotlin
kotlin {
    jvm()
    js()
    ios()

    sourceSets {
        val commonMain by getting
        val myCustomIntermediateSourceSet by creating {
            dependsOn(commonMain)
        }

        // Option #1: shorter and more readable, prefer it where possible
        val jvmMain by getting {  // Usually, the name of the default source set 
                                  // is a simple concatenation of target name + compilation name
            dependsOn(myCustomIntermediateSourceSet)
        }
        
        // Option #2: generic solution, use it if your buildscript calls for a more advanced approach
        targets["jvm"].compilations["main"].defaultSourceSet.dependsOn(myCustomIntermediateSourceSet)
    }
}
```

**When do the changes take effect?**

In 1.9, using `KotlinComplation.source` will provoke a deprecation warning.
In Kotlin >1.9.20 this API will be removed, leading to "unresolved reference" errors on `KotlinCompilation.source`-calls

<anchor name="kotlin-js-plugin-deprecation"></anchor>
## Migration from `kotlin-js` Gradle plugin to `kotlin-multiplatform` Gradle plugin

**What's changed?**

`kotlin-js`-Gradle plugin essentially duplicated the functionality of a `kotlin-multiplatform` plugin with a `js()`-target
and shared the same implementation under the hood. Such overlap created confusion and increased maintenance 
load on the Kotlin Team. Therefore, since Kotlin 1.9, applying a `kotlin-js` Gradle Plugin will trigger a 
deprecation warning. Users are encouraged to migrate to `kotlin-multiplatform` Gradle Plugin with a `js()` target.

**What's the best practice now?**

1. You need to remove the application of a `kotlin-js` Gradle plugin and apply `kotlin-multiplatform`. Here's an 
example of how to do it if you're using `pluginManagement`-block in `settings.gradle.kts`

<table header-style="top">
<tr>
    <td>Before</td>
    <td>Now</td>
</tr>
<tr>

<td>

```kotlin
// settings.gradle.kts
pluginManagement {
    plugins {
        // Remove the following line
        kotlin("js") version "1.9.0"
    }
    
    repositories {
        // ...
    }
}
```

</td>

<td>

```kotlin
// settings.gradle.kts
pluginManagement {
    plugins {
        // Put this line instead
        kotlin("multiplatform") version "1.9.0"
    }
    
    repositories {
        // ...
    }
}
```

</td>
</tr>
</table>

In case you're using a different way of applying plugins, refer to [the Gradle Documentation](https://docs.gradle.org/current/userguide/plugins.html)

2. Move your source files from `main`/`test` folder to `jsMain`/`jsTest` folder in the same directory

3. Adjust dependencies declaration:

We recommend using `sourceSets`-block and configure dependencies of respective source set: `jsMain` for
production dependencies, `jsTest` for test dependencies. See the example below and refer for details to the Kotlin 
Multiplatform Plugin [documentation](https://kotlinlang.org/docs/multiplatform-add-dependencies.html)

If you'd like to keep your dependencies declared in a top-level block:   

`api("group:artifact:1.0")` -> `add("jsMainApi", "group:artifact:1.0")`

Note that in this case, you have to make sure that the top-level `dependencies`-block comes **after** `kotlin`-block,
otherwise you'll get an error like this: `Configuration with name 'jsMainApi' not found.`

<table header-style="top">
<tr>
    <td>Before</td>
    <td>Now</td>
</tr>
<tr>

<td>

```kotlin
// build.gradle.kts
plugins {
    kotlin("js") version "1.9.0"
}

dependencies {
    testImplementation(kotlin("test"))
    implementation("org.jetbrains.kotlinx:kotlinx-html:0.8.0")
}

kotlin {
    js {
        // ...
    }
}
```

</td>

<td>

```kotlin
// build.gradle.kts
plugins {
    kotlin("multiplatform") version "1.9.0"
}

kotlin {
    js {
        // ...
    }
    
    // Option #1: declare dependencies in sourceSets-block:
    sourceSets {
        val jsMain by getting {
            dependencies {
                // no need for 'js'-prefix here, you can do the plain copy-paste from top-level block
                implementation("org.jetbrains.kotlinx:kotlinx-html:0.8.0")
            }
        }
    }
}

dependencies {
   // Option #2: keep the top-level dependencies block
   add("jsTestImplementation", kotlin("test"))
}
```

</td>
</tr>
</table>

4. The DSL provided by Kotlin Gradle Plugin inside `kotlin`-block remains unchanged for most cases. However if you
were referring to low-level Gradle entities (tasks, configurations) by names, you have to adjust the names, usually
by adding `js`-prefix
    * Example: `browserTest`-task can be found under name `jsBrowserTest`

<anchor name="android-target-rename"></anchor>
## Rename of `android` target to `androidTarget`

We continue our efforts to stabilize Kotlin Multiplatform. An essential step in this way is to provide first-class 
support for the Android target. In the future, this support will be provided via a separate plugin, developed by
Android team from Google.

To open the way for the new solution from Google, we’re renaming the `android` block to `androidTarget` in the current 
Kotlin DSL in 1.9.0. This is a temporary change that is necessary to free the short `android` name for the upcoming 
DSL from Google.

The Google plugin will be the preferred way of working with Android in multiplatform projects. When it’s ready, 
we’ll provide the necessary migration instructions so that you’ll be able to use the short `android` name as before.
