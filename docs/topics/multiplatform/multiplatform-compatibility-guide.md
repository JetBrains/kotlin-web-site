[//]: # (title: Compatibility guide for Kotlin Multiplatform)

This guide summarizes [incompatible changes](kotlin-evolution.md#incompatible-changes) you might encounter while
developing projects with Kotlin Multiplatform.

Starting from the Kotlin 1.9.20, we document the versions of external tools recommeded for use in Kotlin Multiplatform 
projects: 

| Kotlin Version | Gradle | Android Gradle Plugin | Xcode |
|----------------|--------|-----------------------|-------|
| 1.9.20         | \>=7.5 | 7.4.2 <=> 8.2         | 15.0  |


> Mind the deprecation cycle of a specific change in relation to the Kotlin version you have in your projects. The current
> Stable version of Kotlin is %kotlinVersion%.
>
{type="note"}



## New approach to auto-generated targets

**What's changed?**

Target accessors auto-generated by Gradle are no longer available inside the `kotlin.targets` block. Use
the `findByName("targetName")` method instead.

Note that such accessors are still available in the `kotlin.targets` case, for example, `kotlin.targets.linuxX64`.

**What's the best practice now?**

<table header-style="top">
    <tr>
        <td>Before</td>
        <td>Now</td>
    </tr>
    <tr>
<td>

```kotlin
kotlin {
    targets {
        configure(['windows',
            'linux']) {
        }
    }
}
```

</td>
<td>

```kotlin
kotlin {
    targets {
        configure([findByName('windows'),
            findByName('linux')]) {
        }
    }
}
```

</td>
    </tr>
</table>

**When do the changes take effect?**

In Kotlin 1.7.20, an error is introduced when using target accessors in the `kotlin.targets` block.

For more information, see the [corresponding issue in YouTrack](https://youtrack.jetbrains.com/issue/KT-47047).

## Changes in Gradle input and output compile tasks

**What's changed?**

Kotlin compile tasks no longer inherit the Gradle `AbstractCompile` task that has the `sourceCompatibility` and
`targetCompatibility` inputs, making them unavailable in Kotlin users' scripts.

Other breaking changes in compile tasks:

**What's the best practice now?**

| Before                                                              | Now                                                                                                            |
|---------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------|
| The `SourceTask.stableSources` input is no longer available.        | Use the `sources` input instead. Also, the `setSource()` methods are still available.                          |
| The `sourceFilesExtensions` input was removed.                      | Compile tasks still implement the `PatternFilterable` interface. Use its methods for filtering Kotlin sources. |
| The `Gradle destinationDir: File` output was deprecated.            | Use the `destinationDirectory: DirectoryProperty` output instead.                                              |
| The `classpath` property of the `KotlinCompile` task is deprecated. | All compile tasks now use the `libraries` input for a list of libraries required for compilation.              |

**When do the changes take effect?**

In Kotlin 1.7.20, inputs are not available, the output is replaced, and the `classpath` property is deprecated.

For more information, see the [corresponding issue in YouTrack](https://youtrack.jetbrains.com/issue/KT-32805).

## New configuration names for dependencies on the compilation

**What's changed?**

Compilation configurations created by the Kotlin Multiplatform Gradle Plugin received new names.

A target in the Kotlin Multiplatform project has two default compilations, `main` and `test`. Each of these compilations
has its own default source set, for example, `jvmMain` and `jvmTest`. Previously the configuration names for the test
compilation and its default source set were the same, which might lead to a name clash resulting in issues when a
configuration marked with platform-specific attributes is included in another configuration.

Now compilation configurations have an extra `Compilation` postfix, while projects and plugins that use old hard-coded
configuration names no longer compile.

Configuration names for dependencies on the corresponding source set stay the same.

**What's the best practice now?**

<table header-style="top">
    <tr>
        <td></td>
        <td>Before</td>
        <td>Now</td>
    </tr>
    <tr>
        <td rowspan="2">Dependencies of the <code>jvmMain</code> compilation</td>
<td>

```kotlin
jvm<Scope>
```

</td>
<td>

```kotlin
jvmCompilation<Scope>
```

</td>
    </tr>
    <tr>
<td>

```kotlin
dependencies {
    add("jvmImplementation",
        "foo.bar.baz:1.2.3")
}
```

</td>
<td>

```kotlin
dependencies {
    add("jvmCompilationImplementation",
        "foo.bar.baz:1.2.3")
}
```

</td>
    </tr>
    <tr>
        <td>Dependencies of the <code>jvmMain</code> source set</td>
<td colspan="2">

```kotlin
jvmMain<Scope>
```

</td>
    </tr>
    <tr>
        <td>Dependencies of the <code>jvmTest</code> compilation</td>
<td>

```kotlin
jvmTest<Scope>
```

</td>
<td>

```kotlin
jvmTestCompilation<Scope>
```

</td>
    </tr>
    <tr>
        <td>Dependencies of the <code>jvmTest</code> source set</td>
<td colspan="2">

```kotlin
jvmTest<Scope>
```

</td>
    </tr>
</table>

The available scopes are `Api`, `Implementation`, `CompileOnly`, and `RuntimeOnly`.

**When do the changes take effect?**

In Kotlin 1.8.0, an error is introduced when using old configuration names in hard-coded strings.

For more information, see the [corresponding issue in YouTrack](https://youtrack.jetbrains.com/issue/KT-35916/).

<anchor name="deprecate-hmpp-properties"></anchor>

## Deprecated Gradle properties for hierarchical structure support

**What's changed?**

Throughout its evolution, Kotlin was gradually introducing the support for [hierarchical structure](multiplatform-hierarchy.md),
in multiplatform projects, an ability to have intermediate source sets between the common source set `commonMain` and
any platform-specific one, for example, `jvmMain`.

For the transition period, while the toolchain wasn't stable enough, a couple of Gradle properties were introduced,
allowing granular opt-ins and opt-outs.

Since Kotlin 1.6.20, the hierarchical project structure support has been enabled by default. However, these properties
were kept for opting out in case of blocking issues. After processing all the feedback, we're now starting to phase out
those properties completely.

The following properties are now deprecated:

* `kotlin.internal.mpp.hierarchicalStructureByDefault`
* `kotlin.mpp.enableCompatibilityMetadataVariant`
* `kotlin.mpp.hierarchicalStructureSupport`
* `kotlin.mpp.enableGranularSourceSetsMetadata`
* `kotlin.native.enableDependencyPropagation`

**What's the best practice now?**

* Remove these properties from your `gradle.properties` and `local.properties` files.
* Avoid setting them programmatically in the Gradle build scripts or your Gradle plugins.
* In case deprecated properties are set by some third-party Gradle plugin used in your build, ask the plugin maintainers
not to set these properties.

As the default behavior of the Kotlin toolchain doesn't include such properties since 1.6.20, we don't expect
any serious impact from removing them. Most possible consequences will be visible immediately after the project rebuild.

If you're a library author and want to be extra safe, check that consumers can work with your library.

**When do the changes take effect?**

* In 1.8.20, usage of these properties provokes a warning
* In 1.9.20, usage of these properties provokes an error
* In 2.0, support for these properties will be removed, and Kotlin Gradle Plugin will ignore them 

In the unlikely case you face some problems after removing these properties, create an [issue in YouTrack](https://kotl.in/issue).

<anchor name="deprecate-pre-hmpp-dependencies"></anchor>
## Deprecated support of multiplatform libraries published in the legacy mode

**What's changed?**

Previously, we [have deprecated
the legacy mode](#deprecated-gradle-properties-for-hierarchical-structure-support) in Kotlin Multiplatform projects
preventing the publication of "legacy" binaries and encouraged you to migrate your projects to the [hierarchical structure](multiplatform-hierarchy.md).

To continue phasing out "legacy" binaries from the ecosystem, starting with Kotlin 1.9.0, the use of legacy libraries
is also discouraged. If your project uses dependencies on legacy libraries, you'll see the following warning:

```none
The dependency group:artifact:1.0 was published in the legacy mode. Support for such dependencies will be removed in the future
```

**What's the best practice now?**

_If you use multiplatform libraries_, most of them have already migrated to the "hierarchical structure" mode,
so you only need to update the library version. See the documentation of the respective libraries for details.

If the library doesn't support non-legacy binaries yet, you can contact the maintainers and tell them about this
compatibility issue.

_If you're a library author_, update the Kotlin Gradle plugin to the latest version and ensure you've fixed the [deprecated Gradle properties](#deprecated-gradle-properties-for-hierarchical-structure-support).

The Kotlin team is eager to help the ecosystem migrate, so if you face any issues, don't hesitate to create an [issue in YouTrack](https://kotl.in/issue).

**When do the changes take effect?**

* 1.9: introduce a deprecation warning for dependencies on legacy libraries
* 2.0: raise the warning for dependencies on legacy libraries to an error
* \>2.0: the support for dependencies on legacy libraries is removed. Using such dependencies can cause build failures

<anchor name="compilation-source-deprecation"></anchor>
## Deprecated API for adding Kotlin source sets directly to the Kotlin compilation

**What's changed?**

The access to `KotlinCompilation.source` has been deprecated. A code like this produces a deprecation warning:

```kotlin
kotlin {
    jvm()
    js()
    ios()
    
    sourceSets {
        val commonMain by getting 
        val myCustomIntermediateSourceSet by creating {
            dependsOn(commonMain)
        }
        
        targets["jvm"].compilations["main"].source(myCustomIntermediateSourceSet)
    }
}
```

**What's the best practice now?**

To replace `KotlinCompilation.source(someSourceSet)`, add the  `dependsOn` relation from the
default source set of the `KotlinCompilation` to `someSourceSet`. We recommend referring to the source directly using `by getting`,
which is shorter and more readable. However, you can also use `KotlinCompilation.defaultSourceSet.dependsOn(someSourceSet)`,
which is applicable in all cases.

You can change the code above in one of the following ways:

```kotlin
kotlin {
    jvm()
    js()
    ios()

    sourceSets {
        val commonMain by getting
        val myCustomIntermediateSourceSet by creating {
            dependsOn(commonMain)
        }

        // Option #1. Shorter and more readable, use it when possible:
       val jvmMain by getting { // Usually, the name of the default source set 
                                // is a simple concatenation of the target name and the compilation name
            dependsOn(myCustomIntermediateSourceSet)
        }
        
        // Option #2. Generic solution, use it if your build script requires a more advanced approach:
        targets["jvm"].compilations["main"].defaultSourceSet.dependsOn(myCustomIntermediateSourceSet)
    }
}
```

**When do the changes take effect?**

* 1.9.0: the use of `KotlinComplation.source` produces a deprecation warning
* 1.9.20: the use of `KotlinComplation.source` produces a deprecation error
* \>1.9.20: `KotlinComplation.source` is removed from the Kotlin Gradle Plugin. Using it will lead to "unresolved 
reference"-errors during the buildscript compilation

<anchor name="kotlin-js-plugin-deprecation"></anchor>
## Migration from `kotlin-js` Gradle plugin to `kotlin-multiplatform` Gradle plugin

**What's changed?**

Starting with Kotlin 1.9.0, the `kotlin-js` Gradle plugin is
deprecated. Basically, it duplicated the functionality of the `kotlin-multiplatform` plugin with the `js()` target
and shared the same implementation under the hood. Such overlap created confusion and increased maintenance
load on the Kotlin team. We encourage you to migrate to the `kotlin-multiplatform` Gradle plugin with the `js()` target instead.

**What's the best practice now?**

1. Remove the `kotlin-js` Gradle plugin from your project and apply `kotlin-multiplatform` in the `settings.gradle.kts` file
   if you're using the `pluginManagement` block:

   <tabs>
   <tab title="kotlin-js">
   
   ```kotlin
   // settings.gradle.kts
   pluginManagement {
       plugins {
           // Remove the following line:
           kotlin("js") version "1.9.0"
       }
       
       repositories {
           // ...
       }
   }
   ```
   
   </tab>
   <tab title="kotlin-multiplatform">
   
   ```kotlin
   // settings.gradle.kts
   pluginManagement {
       plugins {
           // Add the following line instead:
           kotlin("multiplatform") version "1.9.0"
       }
       
       repositories {
           // ...
       }
   }
   ```
   
   </tab>
   </tabs>

   In case you're using a different way of applying plugins,
   see [the Gradle documentation](https://docs.gradle.org/current/userguide/plugins.html) for migration instructions.

2. Move your source files from the `main` and `test` folders to the `jsMain` and `jsTest` folders in the same directory.
3. Adjust dependency declarations:

   * We recommend using the `sourceSets` block and configuring dependencies of respective source sets,
     `jsMain` for production dependencies and `jsTest` for test dependencies.
     See [Adding dependencies](multiplatform-add-dependencies.md) for more details.
   * However, if you want to declare your dependencies in a top-level block,
     change declarations from `api("group:artifact:1.0")` to `add("jsMainApi", "group:artifact:1.0")` and so on.

      > In this case, make sure that the top-level `dependencies` block comes **after** the `kotlin` block. Otherwise, you'll get an error "Configuration not found".
      >
      {type="note"}
   
   You can change the code in your `build.gradle.kts` file in one of the following ways:

   <tabs>
   <tab title="kotlin-js">
   
   ```kotlin
   // build.gradle.kts
   plugins {
       kotlin("js") version "1.9.0"
   }
   
   dependencies {
       testImplementation(kotlin("test"))
       implementation("org.jetbrains.kotlinx:kotlinx-html:0.8.0")
   }
   
   kotlin {
       js {
           // ...
       }
   }
   ```
   
   </tab>
   <tab title="kotlin-multiplatform">
   
   ```kotlin
   // build.gradle.kts
   plugins {
       kotlin("multiplatform") version "1.9.0"
   }
   
   kotlin {
       js {
           // ...
       }
       
       // Option #1. Declare dependencies in the `sourceSets` block:
       sourceSets {
           val jsMain by getting {
               dependencies {
                   // No need for the `js` prefix here, you can just copy and paste it from the top-level block
                   implementation("org.jetbrains.kotlinx:kotlinx-html:0.8.0")
               }
           }
       }
   }
   
   dependencies {
      // Option #2. Add the `js` prefix to the dependency declaration:
      add("jsTestImplementation", kotlin("test"))
   }
   ```
   
   </tab>
   </tabs>

4. The DSL provided by the Kotlin Gradle plugin inside the `kotlin` block remains unchanged in most cases. However,
   if you were referring to low-level Gradle entities, like tasks and configurations, by names, you now need to adjust them,
   usually by adding the `js` prefix. For example, you can find the `browserTest` task under the name `jsBrowserTest`.

**When do the changes take effect?**

In 1.9.0, the use of the `kotlin-js` Gradle plugin produces a deprecation warning.

<anchor name="android-target-rename"></anchor>
## Rename of `android` target to `androidTarget`

**What's changed?**

We continue our efforts to stabilize Kotlin Multiplatform. An essential step in this way is to provide first-class
support for the Android target. In the future, this support will be provided via a separate plugin, developed by the
Android team from Google.

To open the way for the new solution from Google, we're renaming the `android` block to `androidTarget` in the current
Kotlin DSL in 1.9.0. This is a temporary change that is necessary to free the short `android` name for the upcoming DSL
from Google.

**What's the best practice now?**

Rename all the occurrences of  the `android` block to `androidTarget`. When the new plugin for the Android target support
is available, migrate to the DSL from Google. It will be the preferred option to work with Android in Kotlin Multiplatform
projects.

**When do the changes take effect?**

In Kotlin 1.9.0, a deprecation warning is introduced when the `android` name is used in Kotlin Multiplatform projects.

<anchor name="declaring-multiple-targets"></anchor>
## Declaring multiple targets of the same kind

**What's changed?**

We discourage declaring multiple targets of the same kind in a single Gradle project.

Example:
```kotlin
kotlin {
    jvm("jvmKtor")
    jvm("jvmOkio") // is not recommended and will produce deprecation warning
}
```

One popular case is having two related pieces of code together. For example, you might be compelled to use
`jvm("jvmKtor")` and `jvm("jvmOkio")` in your `:shared` Gradle project for providing an implementation of networking
code based on Ktor or OKIO:

```kotlin
// shared/build.gradle.kts
kotlin {
   jvm("jvmKtor") {
       attributes.attribute(/* ... */) 
   }
   jvm("jvmOkio") {
       attributes.attribute(/* ... */) 
   }

   sourceSets {
       val commonMain by getting
       val commonJvmMain by sourceSets.creating {
           dependsOn(commonMain)
           dependencies {
               // shared dependencies
           }
       }
       val jvmKtorMain by getting {
           dependsOn(commonJvmMain)
           dependencies {
               // Ktor dependencies
           }
       }
       val jvmOkioMain by getting {
           dependsOn(commonJvmMain)
           dependencies {
               // OKIO dependencies
           }
       }
   }
}
```

You can see that it comes with a non-trivial configuration complexity:
* You have to set-up Gradle Attributes both on the `:shared`-side and on each consumer side. Otherwise, Gradle won't be
able to resolve dependencies on such projects, because without an additional information it's not clear whether the 
consumer should receive Ktor-based implementation, or OKIO-based implementation
* You have to set-up the `commonJvmMain` source set manually

All this involves a handful of low-level Gradle and KGP abstractions and APIs. 

**What's the best practice now?**

The configuration gets pretty complicated because Ktor-based and OKIO-based implementations are
**in the same Gradle project**. In a lot of cases, it is possible to extract those parts into separate Gradle projects.
Here's the rough outline of this refactoring:

1. Replace two duplicating targets from the original project to one target. If you had a shared source set between
these targets, move its sources and configuration to the default source set of the newly created target:

```kotlin
// shared/build.gradle.kts
kotlin {
    jvm()
    
    sourceSets {
        jvmMain {
            // ... copy the configuration of jvmCommonMain here ...
        }
    }
}
```

2. Add two new Gradle projects, usually by calling `include` in your `settings.gradle.kts`. For example:

```kotlin
include(":okio-impl")
include(":ktor-impl")
```

3. Configure each new Gradle project
   - Most likely, you don't need to apply `kotlin("multiplatform")` plugin, as those projects will compile only for one
   target. In our case, we can apply `kotlin("jvm")`
   - Move the content of original target-specific source sets to their respective projects, e.g. from `jvmKtorMain` to 
   `ktor-impl/src`
   - Copy the configuration of source sets (dependencies, compiler options, etc.)
   - Add a dependency from a new Gradle project to the original one.

```kotlin
// ktor-impl/build.gradle.kts
plugins {
    kotlin("jvm")
}

dependencies {
    project(":shared") // add dependency on the original project
    // ... copy dependencies of jvmKtorMain here ...
}

kotlin {
    compilerOptions {
        // ... copy compiler options of jvmKtorMain here ...
    }
}
```

While this approach requires more initial setup work, it doesn't use any low-level entities of Gradle and KGP, making
easier to work with the resulting build and maintain it.

> Unfortunately, it's too verbose to provide detailed migration instructions for each possible case. If the instructions above don't work
> for your case, please describe your case in the respective [YouTrack-issue](https://youtrack.jetbrains.com/issue/KT-59316)
>{type="note"}

**When do the changes take effect?**

In Kotlin 1.9.20, a deprecation warning is introduced when multiple targets of the same type is used in Kotlin Multiplatform projects.
In Kotlin 2.0, error will be reported in such cases, causing your build to fail.

<anchor name="jvmWithJava-preset-deprecation"></anchor>
## Deprecation of 'jvmWithJava'-preset

**What's changed?**

`targetPresets.jvmWithJava` is deprecated and its usage is discouraged

**What's the best practice now?**

Use `jvm { withJava() }` target instead. Note that after switching to `jvm { withJava() }`, paths for source directories
with .java-sources will need an adjustment. Assuming you use a `jvm`-target with the default name "jvm":
* instead of `src/main/java`, use `src/jvmMain/java`
* instead of `src/test/java`, use `src/jvmTest/java`

**When do the changes take effect?**

* 1.3.40: using `targetPresets.jvmWithJava` provokes a warning
* 1.9.20: using `targetPresets.jvmWithJava` provokes an error
* \>1.9.20: `targetPresets.jvmWithJava` API is removed. Using it will cause the buildscript compilation failure  

> Note that the whole `targetPresets` API is deprecated, but `jvmWithJava`-preset has different deprecation timeline  
> 
>{type="note"}

<anchor name="android-sourceset-layout-v1-deprecation"></anchor>
## Deprecation of the legacy source set layout for Android

Since Kotlin 1.9.0, new layout for Android Source Sets is used (read details about source set layouts 
[here](https://kotlinlang.org/docs/multiplatform-android-layout.html)). Support for the legacy layout is deprecated, 
and using respective Gradle property `kotlin.mpp.androidSourceSetLayoutVersion` will trigger deprecation diagnostic

**When do the changes take effect?**

* <=1.9.0: using `kotlin.mpp.androidSourceSetLayoutVersion=1` provokes a warning that can be suppressed via 
`kotlin.mpp.androidSourceSetLayoutVersion1.nowarn=true` Gradle Property

* 1.9.20: using `kotlin.mpp.androidSourceSetLayoutVersion=1` provokes an error. This error **can not** be suppressed by
`kotlin.mpp.androidSourceSetLayoutVersion1.nowarn=true`

* \>1.9.20: support for `kotlin.mpp.androidSourceSetLayoutVersion=1` is removed, the property is ignored by the 
Kotlin Gradle Plugin

<anchor name="common-sourceset-with-dependson-deprecation"></anchor>
## Deprecation of commonMain and commonTest with custom dependsOn

**What's changed?**

`commonMain` and `commonTest` source sets usually represent roots of `main` and `test` source set hierarchies 
respectively. However, it was possible to override that by configuring `dependsOn`-edges of these source sets.

Maintaining such configuration requires extra effort and knowledge about multiplatform build internals. Additionally, 
it hurts readability and reusability of the code, because without reading the particular buildscript,
you can never be sure if the `commonMain` is the root of the `main` source set hierarchy.

Therefore, accessing `dependsOn` on `commonMain` and `commonTest` is now deprecated.    

**What's the best practice now?**

Suppose you need to migrate to 1.9.20 a source set `customCommonMain` such that `commonMain.dependsOn(customCommonMain)`.

In most cases, `customCommonMain` participates in the same compilations as `commonMain`, so you can just merge the 
`customCommonMain` into `commonMain`:
* copy sources of `customCommonMain` into `commonMain`
* add all dependencies of `customCommonMain` to `commonMain`
* add all compiler option settings of `customCommonMain` to `commonMain`

In rare cases `customCommonMain` might be participating in more compilations than `commonMain` does. It requires additional
low-level configuration of the buildscript, so if you're not sure if that's your case, it most likely isn't. 
If you do have such case, you can "swap" these two source sets: move sources and settings of `customCommonMain` to `commonMain` and vice versa. 

**When do the changes take effect?**
* 1.9.0: warning is reported on `commonMain` with `dependsOn`
* \>=1.9.20: error is reported on `commonMain` or `commonTest` with `dependsOn`

<anchor name="target-presets-deprecation"></anchor>
## Deprecated "target presets" API

**What's changed?**

In the very early development stages, Kotlin Multiplatform introduced an API for working with so-called "target presets".
Each target preset essentially represented a factory for Kotlin Multiplatform targets. This API turned out to be largely
redundant, as DSL functions like `jvm()` or `iosSimulatorArm64()` cover same cases while being much more straightforward
and concise. 

In order to reduce the confusion and provide a clearer guidelines, all presets-related API is now deprecated and will be
removed from public API of the Kotlin Gradle Plugin in future releases. This includes:
* `presets` property in `org.jetbrains.kotlin.gradle.dsl.KotlinMultiplatformExtension`
* `org.jetbrains.kotlin.gradle.plugin.KotlinTargetPreset` interface and all inheritors
* `fromPreset`-overloads 

**What's the best practice now?**

Use respective [Kotlin Targets](https://kotlinlang.org/docs/multiplatform-dsl-reference.html#targets) instead. For
example, instead of:

```kotlin
kotlin {
    targets {
        fromPreset(presets.iosArm64, 'ios')
    }
}
```

use:

```kotlin
kotlin {
    iosArm64()
}
```

As you can see, the replacement is much more concise and cleaner.

**When do the changes take effect?**
* 1.9.20: warning is reported on any usages of presets-related API
* 2.0: error is reported on any usages of presets-related API
* \>2.0: presets-related API is removed from the public API of the Kotlin Gradle Plugin. Sources that still use it
will fail with "unresolved reference"-kind of errors, and binaries (e.g. Gradle plugins) might fail with linkage errors
unless recompiled against modern versions of Kotlin Gradle Plugin.
