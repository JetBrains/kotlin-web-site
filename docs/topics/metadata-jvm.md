[//]: # (title: Kotlin Metadata JVM library)

The [`kotlinx-metadata-jvm`](https://github.com/JetBrains/kotlin/tree/master/libraries/kotlinx-metadata/jvm) library provides tools to read, modify, and generate metadata from Kotlin classes compiled for the JVM.
This metadata, stored in the [`@Metadata`](https://kotlinlang.org/api/core/kotlin-stdlib/kotlin/-metadata/) annotation within `.class` files,
is used by libraries and tools to inspect Kotlin-specific constructs such as properties, functions,
and classes at runtime.
You can also use this library to adjust attributes for binary compatibility validation or to generate and embed metadata into `.class` files.

## Add the library to your project

To include the Kotlin Metadata JVM library in your project, add the appropriate dependency configuration based on your build tool.

### Gradle

Add the following dependency to your `build.gradle(.kts)` file:

<tabs group="build-tool">
<tab title="Kotlin" group-key="kotlin">

```kotlin
// build.gradle.kts
repositories {
   mavenCentral()
}

dependencies {
   implementation("org.jetbrains.kotlin:kotlin-metadata-jvm:%kotlinVersion%")
}
```

</tab>
<tab title="Groovy" group-key="groovy">

```groovy
// build.gradle
repositories {
   mavenCentral()
}

dependencies {
   implementation 'org.jetbrains.kotlin:kotlin-metadata-jvm:%kotlinVersion%'
}
```
</tab>
</tabs>

### Maven

Add the following dependency to your `pom.xml` file.

```xml
<project>
   <dependencies>
       <dependency>
           <groupId>org.jetbrains.kotlin</groupId>
           <artifactId>kotlin-metadata-jvm</artifactId>
           <version>%kotlinVersion%</version>
       </dependency>
   </dependencies>
   ...
</project>
```


## Read and parse metadata

The `kotlinx-metadata-jvm` library enables you to inspect Kotlin class metadata from compiled `.class` files.
You can start exploring Kotlin class metadata by retrieving the `@Metadata` annotation from a compiled class:

```kotlin
// Imports the necessary library
import kotlin.Metadata

fun main() {
    // Specifies the fully qualified name of the class
    val clazz = Class.forName("org.example.SampleClass")

    // Retrieves the @Metadata annotation
    val metadata = clazz.getAnnotation(Metadata::class.java)

    // Checks if the metadata is present
    if (metadata != null) {
        println("This is a Kotlin class with metadata.")
    } else {
        println("This is not a Kotlin class.")
    }
}
```

Once you retrieve the `@Metadata` annotation, use the [`readLenient()`](https://kotlinlang.org/api/kotlinx-metadata-jvm/kotlin-metadata-jvm/kotlin.metadata.jvm/-kotlin-class-metadata/-companion/read-lenient.html) and [`readStrict()`](https://kotlinlang.org/api/kotlinx-metadata-jvm/kotlin-metadata-jvm/kotlin.metadata.jvm/-kotlin-class-metadata/-companion/read-strict.html) functions from the [`KotlinClassMetadata`](https://kotlinlang.org/api/kotlinx-metadata-jvm/kotlin-metadata-jvm/kotlin.metadata.jvm/-kotlin-class-metadata/) API to parse it.
These functions allow you to extract detailed information about classes or files, while addressing different compatibility requirements:

* `readLenient()`: Use this function when you need to read metadata, even if it was generated by a Kotlin compiler version newer than the one supported by your project. This function is limited to introspection and doesn't allow modifications.
* `readStrict()`: Use this function for scenarios where you need to modify and write metadata. This function only works with metadata generated by Kotlin compiler versions fully supported by your project and throws an error for unsupported versions.

When parsing metadata, the `KotlinClassMetadata` instance provides structured information about class or file-level declarations.
For classes, use the `kmClass` property to analyze detailed class-level metadata, such as the class name, functions, properties, and attributes like visibility.
For file-level declarations, the metadata is represented by the `kmPackage` property, which includes top-level functions
and properties from file facades generated by the Kotlin compiler.

For example, the following code demonstrates how to use `readLenient()` to parse metadata, analyze class-level details with `kmClass`, and retrieve file-level declarations with `kmPackage`:

```kotlin
// Imports the necessary libraries
import kotlin.Metadata
import kotlin.metadata.jvm.*
import kotlin.metadata.*


fun main() {
    // Specifies the fully qualified class name
    val className = "org.example.SampleClass"

    try {
        // Retrieves the class object for the specified name
        val clazz = Class.forName(className)

        // Retrieves the @Metadata annotation
        val metadataAnnotation = clazz.getAnnotation(Metadata::class.java)
        if (metadataAnnotation != null) {
            println("Kotlin Metadata found for class: $className")

            // Parses metadata using the readLenient() function
            val metadata = KotlinClassMetadata.readLenient(metadataAnnotation)
            when (metadata) {
                is KotlinClassMetadata.Class -> {
                    val kmClass = metadata.kmClass
                    println("Class name: ${kmClass.name}")

                    // Iterates over functions and checks visibility
                    kmClass.functions.forEach { function ->
                        val visibility = function.visibility
                        println("Function: ${function.name}, Visibility: $visibility")
                    }
                }
                is KotlinClassMetadata.FileFacade -> {
                    val kmPackage = metadata.kmPackage
                    println("File facade functions: ${kmPackage.functions.map { it.name }}")
                }
                else -> {
                    println("Unsupported metadata type: $metadata")
                }
            }
        } else {
            println("No Kotlin Metadata found for class: $className")
        }
    } catch (e: ClassNotFoundException) {
        println("Class not found: $className")
    } catch (e: Exception) {
        println("Error processing metadata: ${e.message}")
        e.printStackTrace()
    }
}
```

### Validate binary compatibility with the Kotlin Metadata JVM library

You can combine the Kotlin Metadata JVM library with bytecode manipulation tools, such as [ASM](https://asm.ow2.io/),
to extract and validate Kotlin metadata embedded in `.class` files.
This approach allows you to inspect and adapt class-level metadata, making it suitable for validation tools like the Binary Compatibility Validator (BCV).

To validate binary compatibility:

1. Read the bytecode of a `.class` file using the ASM library's `ClassReader` class.
This class processes the compiled file and populates a `ClassNode` object, which represents the class structure.
2. Locate the `@Metadata` annotation within the class using the `findAnnotation()` function.
This function searches the visible or invisible annotations in the `ClassNode` for the desired annotation.
3. Parse the extracted metadata using the `readLenient()` function.
4. Inspect the parsed metadata with the `kotlinMetadata` property.
5. Use the parsed information for compatibility checks or further validation with tools like BCV.

Let's look at an example:

```kotlin
// Imports necessary libraries
import kotlin.Metadata
import kotlin.metadata.jvm.*
import kotlin.metadata.*
import org.objectweb.asm.*
import org.objectweb.asm.tree.*
import java.io.File

// Checks if an annotation refers to a specific name
fun AnnotationNode.refersToName(name: String) =
    desc.startsWith('L') && desc.endsWith(';') && desc.regionMatches(1, name, 0, name.length)

// Retrieves annotation values by key
private fun List<Any>.annotationValue(key: String): Any? {
    for (index in (0 until size / 2)) {
        if (this[index * 2] == key) {
            return this[index * 2 + 1]
        }
    }
    return null
}

// Finds a specific annotation in the visible or invisible annotations of a class node
fun ClassNode.findAnnotation(annotationName: String, includeInvisible: Boolean = false): AnnotationNode? {
    val visible = visibleAnnotations?.firstOrNull { it.refersToName(annotationName) }
    if (!includeInvisible) return visible
    return visible ?: invisibleAnnotations?.firstOrNull { it.refersToName(annotationName) }
}

// Operator to simplify retrieving annotation values
operator fun AnnotationNode.get(key: String): Any? = values.annotationValue(key)

// Extracts Kotlin metadata from a class node
val ClassNode.kotlinMetadata: KotlinClassMetadata?
    get() {
        val metadata = findAnnotation("kotlin/Metadata", false) ?: return null
        @Suppress("UNCHECKED_CAST")
        val header = Metadata(
            kind = metadata["k"] as Int?,
            metadataVersion = (metadata["mv"] as List<Int>?)?.toIntArray(),
            data1 = (metadata["d1"] as List<String>?)?.toTypedArray(),
            data2 = (metadata["d2"] as List<String>?)?.toTypedArray(),
            extraString = metadata["xs"] as String?,
            packageName = metadata["pn"] as String?,
            extraInt = metadata["xi"] as Int?
        )
        return KotlinClassMetadata.readStrict(header)
    }

// Converts a file to a ClassNode for bytecode inspection
fun File.toClassNode(): ClassNode {
    val node = ClassNode()
    this.inputStream().use { ClassReader(it).accept(node, ClassReader.SKIP_CODE) }
    return node
}

fun main() {
    val classFilePath = "build/classes/kotlin/main/org/example/SampleClass.class"
    val classFile = File(classFilePath)

    // Loads the class node and extracts metadata
    val classNode = classFile.toClassNode()
    val metadata = classNode.kotlinMetadata
    if (metadata != null && metadata is KotlinClassMetadata.Class) {
        val kmClass = metadata.kmClass

        // Prints class details
        println("Class name: ${kmClass.name}")
        println("Functions:")
        kmClass.functions.forEach { function ->
            println("- ${function.name}, Visibility: ${function.visibility}")
        }

        // Extracts and prints additional metadata details
        val annotation = classNode.findAnnotation("kotlin/Metadata")
        if (annotation != null) {
            println("Annotation values: ${annotation.values}")
        }
    } else {
        println("No Kotlin metadata found or metadata is not of type Class.")
    }
}
```

> 

## Modify metadata

The `kotlinx-metadata-jvm` library enables you to modify Kotlin class metadata, allowing you to adjust visibility attributes,
remove specific declarations, or prepare metadata for binary compatibility checks.

To modify metadata:

1. Parse the metadata by using the `readStrict()` function to load the `@Metadata` annotation into a structured `KotlinClassMetadata` object.
2. Apply modifications by adjusting the metadata, such as filtering functions or altering attributes, directly within `kmClass` or other metadata structures.
3. Use the [`write()`](https://kotlinlang.org/api/kotlinx-metadata-jvm/kotlin-metadata-jvm/kotlin.metadata.jvm/-kotlin-class-metadata/write.html) function to encode the modified metadata into a new `@Metadata` annotation.

Here's an example where private functions are removed from a class's metadata:

```kotlin
// Imports the necessary libraries
import kotlin.Metadata
import kotlin.metadata.jvm.*
import kotlin.metadata.*

fun main() {
    // Specifies the fully qualified class name
    val className = "org.example.SampleClass"

    try {
        // Retrieves the class object for the specified name
        val clazz = Class.forName(className)

        // Retrieves the @Metadata annotation
        val metadataAnnotation = clazz.getAnnotation(Metadata::class.java)
        if (metadataAnnotation != null) {
            println("Kotlin Metadata found for class: $className")

            // Parses metadata using the readStrict() function
            val metadata = KotlinClassMetadata.readStrict(metadataAnnotation)
            if (metadata is KotlinClassMetadata.Class) {
                val kmClass = metadata.kmClass

                // Removes private functions from the class metadata
                kmClass.functions.removeIf { it.visibility == Visibility.PRIVATE }
                println("Removed private functions. Remaining functions: ${kmClass.functions.map { it.name }}")

                // Writes the modified metadata back
                val newMetadata = metadata.write()
                println("Modified metadata: ${newMetadata}")
            } else {
                println("The metadata is not a class.")
            }
        } else {
            println("No Kotlin Metadata found for class: $className")
        }
    } catch (e: ClassNotFoundException) {
        println("Class not found: $className")
    } catch (e: Exception) {
        println("Error processing metadata: ${e.message}")
        e.printStackTrace()
    }
}
```

## Creating metadata from scratch

To create metadata for a Kotlin class file from scratch using the Kotlin Metadata JVM library:

1. Create an instance of `KmClass`, `KmPackage`, or `KmLambda`, depending on the type of metadata you want to generate.
2. Populate the instance with attributes such as the class name, visibility, constructors, and function signatures. Kotlin’s `apply()` function can reduce boilerplate code while setting properties.
3. Use the populated instance to create a `KotlinClassMetadata` object, which can generate a `@Metadata` annotation.
4. Use the `ClassWriter` class from [ASM](https://asm.ow2.io/) to embed the metadata into a `.class` file.
5. Specify the metadata version (for example, `JvmMetadataVersion.LATEST_STABLE_SUPPORTED`) and flags (0 for no flags, or copy flags from existing files if necessary).
6. Access the annotation fields, such as `kind`, `data1` and `data2` to embed the metadata into a `.class` file or process it further.

The following example demonstrates how to create metadata for a simple Kotlin class:

```kotlin
// Imports the necessary libraries
import kotlin.metadata.*
import kotlin.metadata.jvm.*
import org.objectweb.asm.*

fun main() {
    // Creates a KmClass instance
    val klass = KmClass().apply {
        name = "Hello"
        visibility = Visibility.PUBLIC
        constructors += KmConstructor().apply {
            visibility = Visibility.PUBLIC
            signature = JvmMethodSignature("<init>", "()V")
        }
        functions += KmFunction("hello").apply {
            visibility = Visibility.PUBLIC
            returnType = KmType().apply {
                classifier = KmClassifier.Class("kotlin/String")
            }
            signature = JvmMethodSignature("hello", "()Ljava/lang/String;")
        }
    }

    // Serializes metadata into KotlinClassMetadata
    val annotationData = KotlinClassMetadata.Class(
        klass, JvmMetadataVersion.LATEST_STABLE_SUPPORTED, 0
    ).write()

    // Generates a .class file with ASM
    val classBytes = ClassWriter(0).apply {
        visit(Opcodes.V1_6, Opcodes.ACC_PUBLIC, "Hello", null, "java/lang/Object", null)
        visitAnnotation("Lkotlin/Metadata;", true).apply {
            visit("mv", annotationData.metadataVersion)
            visit("k", annotationData.kind)
            visitArray("d1").apply {
                annotationData.data1.forEach { visit(null, it) }
                visitEnd()
            }
            visitArray("d2").apply {
                annotationData.data2.forEach { visit(null, it) }
                visitEnd()
            }
            visitEnd()
        }
        visitEnd()
    }.toByteArray()

    // Writes the generated class file to disk
    java.io.File("Hello.class").writeBytes(classBytes)

    println("Metadata and .class file created successfully.")
}
```

> For a more detailed example, see the [Kotlin Metadata JVM GitHub repository](https://github.com/JetBrains/kotlin/blob/master/libraries/kotlinx-metadata/jvm/test/kotlin/metadata/test/MetadataSmokeTest.kt).
> 
{style="tip"}

## What's next

* [See the API reference for the Kotlin Metadata JVM library](https://kotlinlang.org/api/kotlinx-metadata-jvm/).
* [Check out the Kotlin Metadata JVM GitHub repostiory](https://github.com/JetBrains/kotlin/tree/master/libraries/kotlinx-metadata/jvm).
