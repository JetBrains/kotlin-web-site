[//]: # (title: Kotlin/Native as an Apple framework â€“ tutorial)

> The Objective-C libraries import is [Experimental](components-stability.md#stability-levels-explained).
> All Kotlin declarations generated by the cinterop tool from Objective-C libraries
> should have the `@ExperimentalForeignApi` annotation.
>
> Native platform libraries shipped with Kotlin/Native (like Foundation, UIKit, and POSIX),
> require opt-in only for some APIs. In such cases, you get an IDE warning.
>
{style="warning"}

Kotlin/Native provides bidirectional interoperability with Objective-C/Swift. Objective-C frameworks and libraries can
be used in Kotlin code. Kotlin modules can be used in Swift/Objective-C code too. 

Kotlin/Native comes with a set of pre-imported system frameworks; it's also possible to import an existing framework and
use it from Kotlin. In this tutorial, you'll learn how to create your own framework and use Kotlin/Native code from
Objective-C and Swift applications on macOS and iOS.

In this tutorial, you'll:

* [Create a Kotlin library](#create-a-kotlin-library) and compile it to a framework.
* Examine the generated [Objective-C and Swift API](#generated-framework-headers) code.
* Use the framework from [Objective-C](#use-code-from-objective-c) and [Swift](#use-code-from-swift).
* [Configure Xcode](#xcode-and-framework-dependencies) to use the framework for [macOS](#macos-target) and [iOS](#ios-targets).

While it's possible to use the command line to create a Kotlin framework, either directly or by combining it with a
script file (such as `.sh` or `.bat` file), this approach doesn't scale well for big projects that have hundreds of files
and libraries. Therefore, it's better to compile using a build system, as it helps to download and cache the Kotlin/Native
compiler binaries and libraries with transitive dependencies and run the compiler and tests.
Kotlin/Native can use the [Gradle](https://gradle.org) build system through the [Kotlin Multiplatform plugin](gradle-configure-project.md#targeting-multiple-platforms).

## Create a Kotlin library

> See the [Get started with Kotlin/Native using Gradle](native-gradle.md) tutorial for detailed first steps
> and instructions on how to create a new Kotlin/Native project and open it in IntelliJ IDEA.
>
{style="tip"}

The Kotlin/Native compiler can produce a framework for macOS and iOS from the Kotlin code. The created framework contains
all declarations and binaries needed to use it with Objective-C and Swift. Let's create a Kotlin library first and use it
from an Objective-C program.

1. In the `src/nativeMain/kotlin` directory, create the `hello.kt` file with the library contents:

   ```kotlin
   package example
    
   object Object {
       val field = "A"
   }
    
   interface Interface {
       fun iMember() {}
   }
    
   class Clazz : Interface {
       fun member(p: Int): ULong? = 42UL
   }
    
   fun forIntegers(b: Byte, s: UShort, i: Int, l: ULong?) { }
   fun forFloats(f: Float, d: Double?) { }
    
   fun strings(str: String?) : String {
       return "That is '$str' from C"
   }
    
   fun acceptFun(f: (String) -> String?) = f("Kotlin/Native rocks!")
   fun supplyFun() : (String) -> String? = { "$it is cool!" }
   ```

2. Update your `build.gradle(.kts)` Gradle build file with the following:

    <tabs group="build-script">
    <tab title="Kotlin" group-key="kotlin">
    
    ```kotlin
    plugins {
        kotlin("multiplatform") version "%kotlinVersion%"
    }
    
    repositories {
        mavenCentral()
    }
    
    kotlin {
        macosX64("native") {
            binaries {
                framework {
                    baseName = "Demo"
                }
            }
        }
    }
    
    tasks.wrapper {
        gradleVersion = "%gradleVersion%"
        distributionType = Wrapper.DistributionType.ALL
    }
    ```
    
    </tab>
    <tab title="Groovy" group-key="groovy">
    
    ```groovy
    plugins {
        id 'org.jetbrains.kotlin.multiplatform' version '%kotlinVersion%'
    }
    
    repositories {
        mavenCentral()
    }
    
    kotlin {
        macosX64("native") {
            binaries {
                framework {
                    baseName = "Demo"
                }
            }
        }
    }
    
    wrapper {
        gradleVersion = "%gradleVersion%"
        distributionType = "ALL"
    }
    ```
    
    </tab>
    </tabs>

    The `binaries {}` block configures the project to generate a dynamic or shared library.

    Along with `macosX64`, Kotlin/Native supports the `macosArm64` target for macOS and the `iosX64`, `iosArm64`, and
    `iosSimulatorArm64` targets for iOS. You can replace the `macosX64` with the respective functions:
    
    | Target platform/device | Gradle function     |
    |------------------------|---------------------|
    | macOS x86_64           | `macosX64()`        | 
    | macOS ARM 64           | `macosArm64()`      |
    | iOS ARM 64             | `iosArm64()`        | 
    | iOS x86_64             | `iosX64()`          |
    | iOS Simulator (arm64)  | `iosSimulatorArm64` |

3. Run the `linkNative` Gradle task to build the library in the IDE or by calling the following console command:

   ```bash
   ./gradlew linkNative
   ```
    
Depending on the variant, the build generates the framework into the `build/bin/native/debugFramework`
or the `build/bin/native/releaseFramework` folder. Let's see what's inside.

## Generated framework headers

You can find the generated framework in the `build/bin` directory. Each framework variant contains a header file.
The headers don't depend on the target platform. Header files contain definitions for your Kotlin code and a few
Kotlin-wide declarations.

### Kotlin/Native runtime declarations

In the `build/bin` directory, navigate to the `<Framework variant>/Demo.framework/Headers/Demo.h` header file and
take a look at Kotlin runtime declarations:

```objc
NS_ASSUME_NONNULL_BEGIN
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunknown-warning-option"
#pragma clang diagnostic ignored "-Wincompatible-property-type"
#pragma clang diagnostic ignored "-Wnullability"

#pragma push_macro("_Nullable_result")
#if !__has_feature(nullability_nullable_result)
#undef _Nullable_result
#define _Nullable_result _Nullable
#endif

__attribute__((swift_name("KotlinBase")))
@interface DemoBase : NSObject
- (instancetype)init __attribute__((unavailable));
+ (instancetype)new __attribute__((unavailable));
+ (void)initialize __attribute__((objc_requires_super));
@end

@interface DemoBase (DemoBaseCopying) <NSCopying>
@end

__attribute__((swift_name("KotlinMutableSet")))
@interface DemoMutableSet<ObjectType> : NSMutableSet<ObjectType>
@end

__attribute__((swift_name("KotlinMutableDictionary")))
@interface DemoMutableDictionary<KeyType, ObjectType> : NSMutableDictionary<KeyType, ObjectType>
@end

@interface NSError (NSErrorDemoKotlinException)
@property (readonly) id _Nullable kotlinException;
@end
```

Kotlin classes have a `KotlinBase` base class in Objective-C/Swift; the class extends the `NSObject` class there.
There are also wrappers for collections and exceptions. Most of the collection types are mapped to similar collection
types from the other side:

| Kotlin      | Swift               | Objective-C         |
|-------------|---------------------|---------------------|
| List        | Array               | NSArray             |
| MutableList | NSMutableArray      | NSMutableArray      |
| Set         | Set                 | NSSet               |
| Map         | Dictionary          | NSDictionary        |
| MutableMap  | NSMutableDictionary | NSMutableDictionary |

### Kotlin numbers and NSNumber

The next part of the `Demo.h` file contains number type mappings between Kotlin/Native and `NSNumber`. There is the base
class called `DemoNumber` in Objective-C and `KotlinNumber` in Swift. It extends `NSNumber`.

There are also child classes per Kotlin number type:

| Kotlin    | Swift           | Objective-C        | Simple type          |
|-----------|-----------------|--------------------|----------------------|
| `-`       | `KotlinNumber`  | `<Package>Number`  | `-`                  |
| `Byte`    | `KotlinByte`    | `<Package>Byte`    | `char`               |
| `UByte`   | `KotlinUByte`   | `<Package>UByte`   | `unsigned char`      |
| `Short`   | `KotlinShort`   | `<Package>Short`   | `short`              |
| `UShort`  | `KotlinUShort`  | `<Package>UShort`  | `unsigned short`     |
| `Int`     | `KotlinInt`     | `<Package>Int`     | `int`                |
| `UInt`    | `KotlinUInt`    | `<Package>UInt`    | `unsigned int`       |
| `Long`    | `KotlinLong`    | `<Package>Long`    | `long long`          |
| `ULong`   | `KotlinULong`   | `<Package>ULong`   | `unsigned long long` |
| `Float`   | `KotlinFloat`   | `<Package>Float`   | `float`              |
| `Double`  | `KotlinDouble`  | `<Package>Double`  | `double`             |
| `Boolean` | `KotlinBoolean` | `<Package>Boolean` | `BOOL/Bool`          |

Every number type has a class method to create a new instance from the related simple type. Also, there is an instance method
to extract a simple value back. Schematically, declarations look like that:

```objc
__attribute__((swift_name("Kotlin__TYPE__")))
@interface Demo__TYPE__ : DemoNumber
- (instancetype)initWith__TYPE__:(__CTYPE__)value;
+ (instancetype)numberWith__TYPE__:(__CTYPE__)value;
@end;
```

Here, `__TYPE__` is one of the simple type names, and `__CTYPE__` is the related Objective-C type,
for example, `initWithChar(char)`.

These types are used to map boxed Kotlin number types into Objective-C and Swift.
In Swift, you can call the constructor to create an instance, for example, `KotlinLong(value: 42)`.

### Classes and objects from Kotlin

Let's see how `class` and `object` are mapped to Objective-C and Swift. The generated `Demo.h` file contains the exact
definitions for `Class`, `Interface`, and `Object`:

```objc
__attribute__((swift_name("Interface")))
@protocol DemoInterface
@required
- (void)iMember __attribute__((swift_name("iMember()")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("Clazz")))
@interface DemoClazz : DemoBase <DemoInterface>
- (instancetype)init __attribute__((swift_name("init()"))) __attribute__((objc_designated_initializer));
+ (instancetype)new __attribute__((availability(swift, unavailable, message="use object initializers instead")));
- (DemoULong * _Nullable)memberP:(int32_t)p __attribute__((swift_name("member(p:)")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("Object")))
@interface DemoObject : DemoBase
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)object __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) DemoObject *shared __attribute__((swift_name("shared")));
@property (readonly) NSString *field __attribute__((swift_name("field")));
@end
```

The code is full of Objective-C attributes, which are intended to help use the framework from both Objective-C and
Swift languages. `DemoInterface`, `DemoClazz`, and `DemoObject` are created for `Interface`, `Clazz`, and `Object`,
respectively.

The `Interface` is turned into `@protocol`, while both a `class` and an `object` are represented as `@interface`.
The `Demo` prefix comes from the `-output` parameter of the `kotlinc-native` compiler and the framework name. 
The nullable return type `ULong?` is turned into `DemoULong` in Objective-C.

### Global declarations from Kotlin

All global functions from Kotlin are turned into `DemoHelloKt` in Objective-C and into `HelloKt` in Swift,
where `Demo` is the framework name set by the `-output` parameter of `kotlinc-native`.

```objc
__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("HelloKt")))
@interface DemoHelloKt : DemoBase
+ (NSString * _Nullable)acceptFunF:(NSString * _Nullable (^)(NSString *))f __attribute__((swift_name("acceptFun(f:)")));
+ (void)forFloatsF:(float)f d:(DemoDouble * _Nullable)d __attribute__((swift_name("forFloats(f:d:)")));
+ (void)forIntegersB:(int8_t)b s:(uint16_t)s i:(int32_t)i l:(DemoULong * _Nullable)l __attribute__((swift_name("forIntegers(b:s:i:l:)")));
+ (NSString *)stringsStr:(NSString * _Nullable)str __attribute__((swift_name("strings(str:)")));
+ (NSString * _Nullable (^)(NSString *))supplyFun __attribute__((swift_name("supplyFun()")));
@end
```

Kotlin `String` and Objective-C `NSString*` are mapped transparently. Similarly, `Unit` type from Kotlin is mapped to `void`.
The primitive types are mapped directly. Non-nullable primitive types are mapped transparently.
Nullable primitive types are mapped into `Kotlin<TYPE>*` types, as shown in the [table](#kotlin-numbers-and-nsnumber). 
Both higher-order functions `acceptFunF` and `supplyFun` are included and accept Objective-C blocks.

You can find more information about type mapping in [Interoperability with Swift/Objective-C](native-objc-interop.md#mappings).

## Garbage collection and reference counting

Objective-C and Swift use reference counting. Kotlin/Native has its own garbage collection too.
Kotlin/Native garbage collection is integrated with Objective-C/Swift reference counting.

Unused Kotlin objects are automatically removed. You don't need to use anything special to control the lifetime of
Kotlin/Native instances from Swift or Objective-C.

## Use code from Objective-C

Let's call the framework from Objective-C. For that, create the `main.m` file with the following code:

```objc 
#import <Foundation/Foundation.h>
#import <Demo/Demo.h>

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        [[DemoObject object] field];
        
        DemoClazz* clazz = [[ DemoClazz alloc] init];
        [clazz memberP:42];
        
        [DemoHelloKt forIntegersB:1 s:1 i:3 l:[DemoULong numberWithUnsignedLongLong:4]];
        [DemoHelloKt forIntegersB:1 s:1 i:3 l:nil];
        
        [DemoHelloKt forFloatsF:2.71 d:[DemoDouble numberWithDouble:2.71]];
        [DemoHelloKt forFloatsF:2.71 d:nil];
        
        NSString* ret = [DemoHelloKt acceptFunF:^NSString * _Nullable(NSString * it) {
            return [it stringByAppendingString:@" Kotlin is fun"];
        }];
        
        NSLog(@"%@", ret);
        return 0;
    }
}
```

Here, you call Kotlin classes directly from Objective-C code. A Kotlin `object` has the class method function `object`,
which allows you to get the object's only instance and call `Object` methods on it.

The widespread pattern is used to create an instance of the `Clazz` class. You call the `[[ DemoClazz alloc] init]` on
Objective-C. You can also use `[DemoClazz new]` for constructors without parameters.

Global declarations from the Kotlin sources are scoped under the `DemoHelloKt` class in Objective-C.
All methods are turned into class methods of that class.

The `strings` function is turned into `DemoHelloKt.stringsStr` function in Objective-C, so you can pass `NSString`
directly to it. The return is visible as `NSString` too.

## Use code from Swift

The framework you compiled has helper attributes to make it easier to use with Swift. Let's convert the previous
Objective-C example into Swift. Create the `main.swift` file with the following code:

```swift
import Foundation
import Demo

let kotlinObject = Object()
assert(kotlinObject === Object(), "Kotlin object has only one instance")

let field = Object().field

let clazz = Clazz()
clazz.member(p: 42)

HelloKt.forIntegers(b: 1, s: 2, i: 3, l: 4)
HelloKt.forFloats(f: 2.71, d: nil)

let ret = HelloKt.acceptFun { "\($0) Kotlin is fun" }
if (ret != nil) {
    print(ret!)
}
``` 

There are some small differences between the original Kotlin code and its Swift version. In Kotlin, any `object` has 
only one instance. Kotlin `object Object` now has a constructor in Swift, and the `Object()` syntax is used to access
its only instance. The instance is always the same in Swift, so that `Object() === Object()` is true.

Methods and property names are translated as is. For example, Kotlin's `String` is turned into Swift's `String`. Swift
hides `NSNumber*` boxing too. You can also pass a Swift closure to Kotlin and call a Kotlin lambda function from Swift. 

You can find more information about type mapping in [Interoperability with Swift/Objective-C](native-objc-interop.md#mappings).

## Xcode and framework dependencies

To use the framework, configure your Xcode project.  First, include the compiled framework in the Xcode project:

1. In Xcode, open the project settings by double-clicking the project name.
2. Select the target, then open the **General** tab.
3. Scroll down to the **Frameworks, Libraries, and Embedded Content** section and add your framework:

   ![Add framework to the project settings](xcode-ios-add-framework.png){width=700}

This makes Xcode consider the framework and resolve imports both from Objective-C and Swift.

The further configuration depends on the target platform.

### macOS target

For macOS, configure the framework search path of the produced binary. It's also known as `rpath` or [run-time search path](https://en.wikipedia.org/wiki/Rpath).
The binary uses this path to look for the required frameworks.

Depending on your application's layout, you may have the **Frameworks** folder under the application bundle with
all the frameworks you use. We do not recommend installing additional frameworks to the OS if they're unnecessary.

To configure the `@rpath` parameter in Xcode:

1. Open the **Build Settings** tab.
2. Scroll down to the **Runpath Search Paths** section and specify the relative path to the compiled framework.

### iOS targets

For iOS, configure the framework search path of the produced binary:

1. Open the **Build Settings** tab.
2. Scroll down to the **Search path** section and include the framework path in the **Framework Search Paths** section.
   
   It's possible to use the `$(PROJECT_DIR)` macro to simplify the setup.
 
The iOS simulator requires a framework compiled for the `ios_x64` target, the `iOS_sim` folder in this case.

> See [this Stack Overflow thread](https://stackoverflow.com/questions/30963294/creating-ios-osx-frameworks-is-it-necessary-to-codesign-them-before-distributin)
> for more recommendations. Also, try the [CocoaPods integration](native-cocoapods.md) to automate the process.
> 
{style="tip"}

## What's next

* [Learn more about interoperability with Objective-C](native-objc-interop.md)
* [See how interoperability with C is implemented in Kotlin](native-c-interop.md)
* [Check out the Kotlin/Native as a dynamic library tutorial](native-dynamic-libraries.md)