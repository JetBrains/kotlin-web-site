<topic xsi:noNamespaceSchemaLocation="https://resources.jetbrains.com/stardust/topic.v2.xsd"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="js-react"
       title="Build a web application with React and Kotlin/JS â€” tutorial">
    <p>This tutorial will teach you how to build a browser application with Kotlin/JS and the
        <a href="https://reactjs.org/">React</a>
        framework using the Gradle plugin. You will:
    </p>
    <list>
        <li>Complete usual kinds of tasks associated with building a typical React application</li>
        <li>Explore how domain-specific languages can be used to help express concepts concisely and uniformly without
            sacrificing
            readability, allowing to write a fully-fledged application completely in Kotlin
        </li>
        <li>Learn how to use ready-made components created by the community, use external libraries, and publish the
            final application
        </li>
    </list>
    <p>The output will be a website with an overview of the <a href="https://kotlinconf.com/">KotlinConf</a> event with
        links to talks,
        which users can mark as seen or unseen and watch them all on one page.
    </p>
    <p>The tutorial assumes you have prior knowledge of Kotlin and basic knowledge of HTML and CSS. Understanding the
        basic
        concepts behind React may help understand some of the sample code but is not strictly required.
    </p>
    <note>
        <p>You can get the final application as well as the intermediate steps <a
                href="https://github.com/kotlin-hands-on/web-app-react-kotlin-js-gradle">here</a>.
            Each step is available from its own branch, and is linked at the bottom of each corresponding section.
        </p>
    </note>
    <chapter id="before-you-start" title="Before you start">
        <p>Download and install the latest version of <a href="https://www.jetbrains.com/idea/download/index.html">
            IntelliJ IDEA</a>.
            Clone the <a href="https://github.com/kotlin-hands-on/web-app-react-kotlin-js-gradle">project template</a> and
            open it in IntelliJ
            IDEA. The template includes a basic Kotlin/JS Gradle project with all required configurations and
            dependencies:
        </p>
        <p>
            <b>Dependencies and tasks in the Gradle file</b>
        </p>
        <code style="block" lang="kotlin"><![CDATA[dependencies {

    //React, React DOM + Wrappers (chapter 3)
    implementation(&quot;org.jetbrains:kotlin-react:17.0.2-pre.154-kotlin-1.5.0&quot;)
    implementation(&quot;org.jetbrains:kotlin-react-dom:17.0.2-pre.154-kotlin-1.5.0&quot;)
    implementation(npm(&quot;react&quot;, &quot;17.0.2&quot;))
    implementation(npm(&quot;react-dom&quot;, &quot;17.0.2&quot;))

    //Kotlin Styled (chapter 3)
    implementation(&quot;org.jetbrains:kotlin-styled:5.2.3-pre.154-kotlin-1.5.0&quot;)
    implementation(npm(&quot;styled-components&quot;, &quot;~5.2.3&quot;))

    //Video Player (chapter 7)
    implementation(npm(&quot;react-youtube-lite&quot;, &quot;1.0.1&quot;))

    //Share Buttons (chapter 7)
    implementation(npm(&quot;react-share&quot;, &quot;~4.2.1&quot;))

    //Coroutines (chapter 8)
    implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.5.0-RC&quot;)
}
]]></code>
        <p>
            <b>An HTML page in <code>/src/main/resources/index.html</code> to insert HTML code
            </b>
        </p>
        <code style="block" lang="xml"><![CDATA[&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Hello, Kotlin/JS!&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
    &lt;script src=&quot;confexplorer.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
]]></code>
        <p>The Kotlin/JS Gradle plugin will bundle all of your code and its dependencies into a single JavaScript file,
            which has
            the same name as the project: <code>confexplorer.js</code>. As a typical <a
                    href="https://faqs.skillcrush.com/article/176-where-should-js-script-tags-be-linked-in-html-documents">
                JavaScript convention</a>,
            the content of the body (including the <code>root</code> div) is loaded first to ensure that the browser
            loads all page elements
            before the scripts. See the following code snippet in <code>src/main/kotlin/Main.kt</code>:
        </p>
        <code style="block" lang="kotlin"><![CDATA[import kotlinx.browser.document

fun main() {
   document.bgColor = &quot;red&quot;
}
]]></code>
        <chapter id="test-the-development-server" title="Test the development server">
            <p>The kotlin.js Gradle plugin comes by default with support for an embedded webpack-dev-server, allowing to
                run
                the application from the IDE without manually setting up any kind of server. To test that the program is
                reaching
                the browser and executes, start the development server by invoking the run or <code>
                    browserDevelopmentRun
                </code> (available in other
                directory or kotlin browser directory) task from the Gradle tool window inside IntelliJ IDEA:
            </p>
            <p>
                <img src="./assets/browserDevelopmentRun.png" alt=""/>
            </p>
            <p>To run the program from the Terminal, use <code>./gradlew run</code> instead.
                When the project is compiled and bundled, a red, blank page will appear in a browser window:
            </p>
            <p>
                <img src="./assets/redPage.png" alt=""/>
            </p>
        </chapter>
        <chapter id="enable-hot-reload-continuous-mode" title="Enable hot reload / continuous mode">
            <p>Instead of manually compiling and executing your project every time the changes are made, configure the
                continuous
                compilation mode. Make sure to stop all running development server instances before proceeding.
                Edit a run configuration that IntelliJ IDEA automatically generates after running the Gradle run task
                for the first time:
            </p>
            <p>In the <b>Run/Debug Configurations</b> dialog, add the <code>--continuous</code> flag to the arguments
                for the run configuration:
            </p>
            <p>After applying the changes, you can use the play button inside IntelliJ IDEA to start the development
                server back up.
                To run the Gradle continuous builds from the Terminal, use <code>./gradlew run --continuous</code> instead.
                To test this feature, change the color of the page to blue in the <code>Main.kt</code> file while the
                Gradle task is running:
            </p>
            <code style="block" lang="kotlin"><![CDATA[document.bgColor = &quot;blue&quot;
]]></code>
            <p>The project will be recompiled, and the browser page will reflect the new hue after the reload.
                During the development, you can leave the development server running. It will automatically recompile
                and reload the page
                while it is running when you make some changes.
            </p>
            <blockquote type=" note">
                <p>You can find the state of the project after this section on the master branch <a
                        href="https://github.com/kotlin-hands-on/web-app-react-kotlin-js-gradle/tree/master">here</a>.
                </p>
            </blockquote>
        </chapter>
    </chapter>
    <chapter id="create-the-first-static-page-with-react" title="Create the first static page with React">
        <p>Change the code in the <code>Main.kt</code> file as follows:
        </p>
        <code style="block" lang="kotlin"><![CDATA[import react.dom.*
import kotlinx.browser.document

fun main() {
    render(document.getElementById(&quot;root&quot;)) {
        h1 {
            +&quot;Hello, React+Kotlin/JS!&quot;
        }
    }
}
]]></code>
        <p>When the project is recompiled, an HTML page in your browser should display:</p>
        <p>
            <img src="./assets/image-20190729142055566.png" alt="image-20190729142055566"/>
        </p>
        <list>
            <li>The <code>render()</code> function instructs
                <a href="https://github.com/JetBrains/kotlin-wrappers/tree/master/kotlin-react-dom">kotlin-react-dom</a>
                to render out a component into an element in the website. If you go back to the
                /src/main/resources/index.html, you can
                see a container element called <code>root</code>, into which the content is rendered. The content is
                pretty simple and uses
                a typesafe DSL to render HTML.
            </li>
            <li>
                <code>h1</code>
                is a function that takes a lambda parameter. When you add the <code>+</code> sign in front of the string
                literal,
                the <code>unaryPlus()</code> function is actually invoked using <a
                    href="https://kotlinlang.org/docs/reference/operator-overloading.html">operator overloading</a>).
                It appends the string to the enclosed HTML element.
            </li>
        </list>
    </chapter>
    <chapter id="create-a-website-draft-with-kotlin-code-instead-of-html"
             title="Create a website draft with Kotlin code instead of HTML">
        <p>Kotlin's support for Domain Specific Languages (DSLs), a feature provided through <a
                href="https://github.com/JetBrains/kotlin-wrappers/blob/master/kotlin-react/README.md">kotlin-react</a>,
            helps to describe a markup language like HTML using a syntax that is easy to read for those familiar with
            HTML.
            Compare classic HTML code for the future website and its typesafe variant in Kotlin:
        </p>
        <tabs>
            <tab>
                <code style="block" lang="kotlin"><![CDATA[h1 {
    +&quot;KotlinConf Explorer&quot;
}
div {
    h3 {
        +&quot;Videos to watch&quot;
    }
    p {
        +&quot;John Doe: Building and breaking things&quot;
    }
    p {
        +&quot;Jane Smith: The development process&quot;
    }
    p {
        +&quot;Matt Miller: The Web 7.0&quot;
    }

    h3 {
        +&quot;Videos watched&quot;
    }
    p {
        +&quot;Tom Jerry: Mouseless development&quot;
    }
}
div {
    h3 {
        +&quot;John Doe: Building and breaking things&quot;
    }
    img {
        attrs {
            src = &quot;https://via.placeholder.com/640x360.png?text=Video+Player+Placeholder&quot;
        }
    }
}
]]></code>
            </tab>
            <tab>
                <code style="block" lang="xml"><![CDATA[&lt;h1&gt;KotlinConf Explorer&lt;/h1&gt;
&lt;div&gt;
&lt;h3&gt;Videos to watch&lt;/h3&gt;
&lt;p&gt;John Doe: Building and breaking things&lt;/p&gt;
&lt;p&gt;Jane Smith: The development process&lt;/p&gt;
&lt;p&gt;Matt Miller: The Web 7.0&lt;/p&gt;
&lt;h3&gt;Videos watched&lt;/h3&gt;
&lt;p&gt;Tom Jerry: Mouseless development&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;h3&gt;John Doe: Building and breaking things&lt;/h3&gt;
&lt;img src=&quot;https://via.placeholder.com/640x360.png?text=Video+Player+Placeholder&quot;/&gt;
&lt;/div&gt;
]]></code>
            </tab>
        </tabs>
        <p>Type or paste the above Kotlin code as the contents of your render call. If IntelliJ IDEA complains about
            missing imports, invoke the corresponding quick fixes using <b>Alt+Enter</b>.
            Wait for the browser to reload. The page should now look like this:
        </p>
        <chapter id="add-videos-using-kotlin-constructs-in-markup" title="Add videos using Kotlin constructs in markup">
            <p>Now, add the list of videos as a list of Kotlin objects:</p>
            <list type="decimal">
                <li>Create a simple data class called <code>KotlinVideo</code> to hold together the attributes of a
                    video. You can add it in
                    <code>Main.kt</code>
                    or any other file.
                </li>
                <li>Define a corresponding external interface, which will be useful for getting data from a real API
                </li>
            </list>
            <code style="block" lang="kotlin"><![CDATA[   external interface Video {
   val id: Int
   val title: String
   val speaker: String
   val videoUrl: String
   }
   
   data class KotlinVideo(
   override val id: Int,
   override val title: String,
   override val speaker: String,
   override val videoUrl: String
   ) : Video
]]></code>
            <list start="3" type="decimal">
                <li>Fill up the two lists for unwatched videos and watched videos, respectively. For now, add these
                    declarations at
                    file-level in <code>Main.kt</code>:
                </li>
            </list>
            <code style="block" lang="kotlin"><![CDATA[val unwatchedVideos = listOf(
   KotlinVideo(1, &quot;Building and breaking things&quot;, &quot;John Doe&quot;, &quot;https://youtu.be/PsaFVLr8t4E&quot;),
   KotlinVideo(2, &quot;The development process&quot;, &quot;Jane Smith&quot;, &quot;https://youtu.be/PsaFVLr8t4E&quot;),
   KotlinVideo(3, &quot;The Web 7.0&quot;, &quot;Matt Miller&quot;, &quot;https://youtu.be/PsaFVLr8t4E&quot;)
)

val watchedVideos = listOf(
   KotlinVideo(4, &quot;Mouseless development&quot;, &quot;Tom Jerry&quot;, &quot;https://youtu.be/PsaFVLr8t4E&quot;)
)
]]></code>
            <list start="4" type="decimal">
                <li>To pull this information back into HTML, write a loop in your Kotlin code to iterate over the
                    collection items and add
                    an HTML element for each of them:
                </li>
            </list>
            <code style="block" lang="kotlin"><![CDATA[for(video in unwatchedVideos) {
   p {
       +&quot;${video.speaker}: ${video.title}&quot;
   }
}
]]></code>
            <p>You can use the same process to modify the code for the <code>watchedVideos</code>. Wait for the browser
                to reload. You should see
                that this change is rendering the equivalent list as above.
            </p>
        </chapter>
        <chapter id="add-styles-with-typesafe-css" title="Add styles with typesafe CSS">
            <p>
                <a href="https://github.com/JetBrains/kotlin-wrappers/tree/master/kotlin-styled">kotlin-styled</a>
                provides typesafe wrappers for
                <a href="https://www.styled-components.com/">styled-components</a>
                allowing to quickly and safely define styles
                <a href="https://github.com/JetBrains/kotlin-wrappers/blob/master/kotlin-styled/README.md#global-styles">
                    globally
                </a>
                or for individual elements of the DOM. It wraps the styled-components library and allows building
                constructs that look like <a href="https://reactjs.org/docs/faq-styling.html#what-is-css-in-js">
                CSS-in-JS</a>.
                You don't need to perform any extra steps to start using this functionality because there already are
                necessary dependencies in your Gradle configuration:
            </p>
            <code>dependencies {
                //...
                //Kotlin Styled
                implementation(&amp;quot;org.jetbrains:kotlin-styled:5.2.1-pre.148-kotlin-1.4.21&amp;quot;)
                implementation(npm(&amp;quot;styled-components&amp;quot;, &amp;quot;~5.2.1&amp;quot;))
                //...
                }
            </code>
            <p>Instead of writing out HTML elements like <code>div</code> or <code>h3</code>, you can use their styled
                counterparts, <code>styledDiv</code> or <code>styledH3</code>,
                making it possible to specify CSS styles in the body. For example, to move the video player to the top
                right corner of the page,
                adjust the code to look like this:
            </p>
            <code>styledDiv {
                css {
                position = Position.absolute
                top = 10.px
                right = 10.px
                }
                h3 {
                + &amp;quot;John Doe: Building and breaking things&amp;quot;
                }
                img {
                attrs {
                src = &amp;quot;https://via.placeholder.com/640x360.png?text=Video+Player+Placeholder&amp;quot;
                }
                }
                }
            </code>
            <p>IntelliJ IDEA will complain about unresolved references. Use quick-fixes via <b>Alt-Enter</b> or add
                necessary imports to
                the top of the file:
            </p>
            <code style="block" lang="kotlin"><![CDATA[import kotlinx.css.*
import styled.*
]]></code>
            <p>You can try making the headline use a <code>fontFamily</code> that is sans-serif, for example, or define
                some more beautiful colors
                in your code.
            </p>
            <blockquote type=" note">
                <p>You can find the state of the project after this section on the step-02-first-static-page branch <a
                        href="https://github.com/kotlin-hands-on/web-app-react-kotlin-js-gradle/tree/step-02-first-static-page">
                    here</a>.
                </p>
            </blockquote>
        </chapter>
    </chapter>
    <chapter id="add-the-first-component" title="Add the first component">
        <p>The basic building blocks in React are called components. You build your application by combining these
            components, which can also be composed of other smaller components. By structuring the components for
            reusability and keeping them generic, you'll be able to use them in multiple parts of the application
            without duplicating code or logic.
            The <code>root</code> node that is currently rendering is already a React component. The current layout of
            your application looks like this:
        </p>
        <p>If you structure the application and split it up into components, you'll end up with a more structured
            layout, in which each component handles its responsibilities:
        </p>
        <p>Creating components that encapsulate a particular functionality shortens source code and makes it easier to
            read and understand.
        </p>
        <chapter id="structure-your-application" title="Structure your application">
            <p>First, explicitly specify the main component for rendering into the <code>root</code> element: the <code>
                App</code>:
            </p>
            <list type="decimal">
                <li>Create a new file in the <code>src/main/kotlin</code> folder called <code>App.kt</code>.
                </li>
                <li>Inside this file, create the <code>App</code> class, which inherits from RComponent, a React
                    Component. For now, keep its generic default parameters (RProps and RState).
                </li>
                <li>Move all typesafe HTML into the <code>render()</code> function. Now all HTML is in its explicit
                    component.
                </li>
            </list>
            <code>import react.*
                â€‹
                @JsExport
                class App : RComponent&amp;lt;RProps, RState&amp;gt;() {
                override fun RBuilder.render() {
                // typesafe HTML goes here!
                }
                }
            </code>
            <p>In the <code>Main.kt</code> file, update the <code>main()</code> function. It should reference <code>
                App
            </code> instead of rendering its own HTML. Specify that the <code>App</code> component is a child of the <code>
                root
            </code> object:
            </p>
            <code>fun main() {
                render(document.getElementById(&amp;quot;root&amp;quot;)) {
                child(App::class) {}
                }
                }
            </code>
            <p>For more information on how React and its components operate, see its <a
                    href="https://reactjs.org/docs/hello-world.html#how-to-read-this-guide">documentation and guides</a>.
            </p>
        </chapter>
        <chapter id="extract-a-list-component" title="Extract a list component">
            <p>Since the <code>watchedVideos</code> and <code>unwatchedVideos</code> lists both display a list of
                videos, it makes sense to create a single reusable component.
                Create a new file called <code>VideoList.kt</code>. The <code>VideoList</code> class follows the same
                pattern as the <code>App</code> class from before, inheriting from RComponent, and containing the code
                from the <code>unwatchedVideos</code> list.
            </p>
            <code>import react.*
                import react.dom.*
                â€‹
                @JsExport
                class VideoList: RComponent&amp;lt;RProps, RState&amp;gt;() {
                override fun RBuilder.render() {
                for (video in unwatchedVideos) {
                p {
                +&amp;quot;${video.speaker}: ${video.title}&amp;quot;
                }
                }
                }
                }
            </code>
            <p>The video-list part of <code>App</code> should look like this:
            </p>
            <code>div {
                h3 {
                +&amp;quot;Videos to watch&amp;quot;
                }
                child(VideoList::class) {}
                â€‹
                h3 {
                +&amp;quot;Videos watched&amp;quot;
                }
                child(VideoList::class) {}
                }
            </code>
        </chapter>
        <chapter id="add-props" title="Add props">
            <p>To reuse the list, it should be possible to fill it with different content. So instead of having the list
                of items stored inside the component's class, it should be controlled externally and passed in as an
                attribute for the component. In React, these attributes are called props. If props change in React, the
                framework will render the page. Add a prop that contains the list of talks:
                Within <code>VideoList.kt</code>, add an interface definition:
            </p>
            <code>external interface VideoListProps: RProps {
                var videos: List&amp;lt;Video&amp;gt;
                }
            </code>
            <list start="2" type="decimal">
                <li>Adjust the class definition of <code>VideoList</code> to make use of those props:
                </li>
            </list>
            <code>@JsExport
                class VideoList: RComponent&amp;lt;VideoListProps, RState&amp;gt;() {
                override fun RBuilder.render() {
                for (video in props.videos) {
                p {
                key = video.id.toString()
                +&amp;quot;${video.speaker}: ${video.title}&amp;quot;
                }
                }
                }
                }
            </code>
            <list start="3" type="decimal">
                <li>Because the content of lists is now potentially dynamic (i.e., during runtime, the attributes passed
                    into your component might change), you also need to add a key attribute. This helps the React
                    renderer figure out which parts of the list need to refresh and which ones can stay the same.
                    You can find more information about lists and keys in the <a
                            href="https://reactjs.org/docs/lists-and-keys.html">React guide</a>.
                    Now, at the usage site within <code>App</code>, make sure that the child components are instantiated
                    with proper attributes. Replace the two loops underneath the <code>h3</code> elements with the
                    respective attributes for <code>unwatchedVideos</code> and <code>watchedVideos</code> :
                </li>
            </list>
            <code>child(VideoList::class) {
                attrs.videos = unwatchedVideos
                }
            </code>
            <p>The browser reload will show that the lists now render as they are supposed to.</p>
        </chapter>
        <chapter id="simplify-your-code" title="Simplify your code">
            <p>You can also use <a
                    href="https://kotlinlang.org/docs/reference/lambdas.html#function-literals-with-receiver">lambdas
                with receivers
            </a> to make the usage site of the component nicer:
            </p>
            <code>fun RBuilder.videoList(handler: VideoListProps.() -&amp;gt; Unit): ReactElement {
                return child(VideoList::class) {
                this.attrs(handler)
                }
                }
            </code>
            <list>
                <li>The code above defines a function called <code>videoList()</code> as an <a
                        href="https://kotlinlang.org/docs/reference/extensions.html">extension function
                </a> on RBuilder.
                </li>
                <li>The function takes one parameter, handler, an extension function on <code>VideoListProps</code> returning <code>
                    Unit</code>.
                </li>
                <li>This function wraps the call to the child (same as before) and passes the handler to instantiate the <code>
                    attrs</code>.
                </li>
            </list>
            <p>Therefore, the usage site can be further simplified:</p>
            <code>videoList {
                videos = unwatchedVideos
                }
            </code>
        </chapter>
        <chapter id="make-it-interactive" title="Make it interactive">
            <p>The final goal for the list component is to have it control the video that's currently being played in
                the video player. For that, the list first needs to allow the user to interact with its elements. To
                start, add alerting the video object the user has selected.
                To do this, modify the code inside the <code>VideoList()</code> render function inside the loop to
                include a handler that alerts the current element:
            </p>
            <code>p {
                key = video.id.toString()
                attrs {
                onClickFunction = {
                window.alert(&amp;quot;Clicked $video!&amp;quot;)
                }
                }
                +&amp;quot;${video.speaker}: ${video.title}&amp;quot;
                }
            </code>
            <p>When IntelliJ IDEA prompts you to add imports for this functionality, use the <b>Alt+Enter</b> quick
                fixes. Alternatively, you can add the required imports manually:
            </p>
            <code>import kotlinx.html.js.onClickFunction
                import kotlinx.browser.window
            </code>
            <p>Now, if you click on one of the list items in the browser window, you'll get the following information
                inside an alert message:
            </p>
            <p>Defining an <code>onClickFunction()</code> directly as lambda is concise and very useful for prototyping.
                However, the way equality <a href="https://youtrack.jetbrains.com/issue/KT-15101">currently works</a> in
                Kotlin/JS is not the most performance-optimized way of passing click handlers. If you want to optimize
                rendering performance, consider storing your functions in a variable and passing them.
            </p>
        </chapter>
        <chapter id="add-state" title="Add state">
            <p>Instead of alerting the user, you can add a â–¶ triangle to highlight the selected video. To do that,
                introduce some state-specific to this component:
                Define an interface, just as you did with props:
            </p>
            <code>external interface VideoListState: RState {
                var selectedVideo: Video?
                }
            </code>
            <p>Adjust the class definition of <code>VideoList</code> to use the <code>VideoListState</code> â€“
                specifically, make inherit from an <code>RComponent&amp;lt;..., VideoListState&amp;gt;</code>.
                Prepend a triangle string for the currently selected element of the list. Modify the <code>
                    onClickFunction()
                </code> to set the contents of <code>selectedVideo</code> to be equal to the element in your list.
                To ensure that components are re-rendered when changing the state, wrap the variable update in the <code>
                    setState
                </code> lambda.
            </p>
            <code>@JsExport
                class VideoList : RComponent&amp;lt;VideoListProps, VideoListState&amp;gt;() {
                override fun RBuilder.render() {
                for (video in props.videos) {
                p {
                key = video.id.toString()
                attrs {
                onClickFunction = {
                setState {
                selectedVideo = video
                }
                }
                }
                if (video == state.selectedVideo) {
                + &amp;quot;â–¶&amp;quot;
                }
                +&amp;quot;${video.speaker}: ${video.title}&amp;quot;
                }
                }
                }
                }
            </code>
            <blockquote type=" warning">
                <p>State should only ever be modified from within the <code>setState</code> lambda. This allows the
                    React renderer to detect any state changes and re-render portions of the UI quickly &amp;gt; and
                    efficiently.
                </p>
            </blockquote>
            <p>You can find more details about states in the <a href="https://reactjs.org/docs/faq-state.html">React
                FAQ</a>.
            </p>
            <blockquote type=" note">
                <p>You can find the state of the project after this section on the step-03-first-component branch <a
                        href="https://github.com/kotlin-hands-on/web-app-react-kotlin-js-gradle/tree/step-03-first-component">
                    here</a>.
                </p>
            </blockquote>
        </chapter>
    </chapter>
    <chapter id="compose-components" title="Compose components">
        <p>Currently, two video lists work on their own. It means that users can select two videos both in the unwatched
            and watched videos lists, even there's only one player:
        </p>
        <p>It happens because both lists share some overarching state: the selected video, as there can only be one
            selected video application-wide. However, this shared state can't (and shouldn't be) stored within the
            individual components but lifted out.
        </p>
        <chapter id="lift-state" title="Lift state">
            <p>To prevent components from being hard-wired together, React props are always passed in from the parent
                component, enforcing a proper hierarchy. If different components want to change the state of their
                sibling components, they can only do it through their parent. At that point, the state is no longer that
                of a sibling component but of the parent component. The process of migrating states from components to
                their parents is called lifting state.
                To lift the state, add the state to the <code>App</code> component. The process is similar to the one
                with <code>VideoList</code>:
                Define an interface:
            </p>
            <code>external interface AppState : RState {
                var currentVideo: Video?
                }
            </code>
            <p>Make sure to use this interface in the <code>App</code> class:
            </p>
            <code>@JsExport
                class App : RComponent&amp;lt;RProps, AppState&amp;gt;()
            </code>
            <p>Delete the VideoListState since it is stored somewhere further up the hierarchy now.
                At this point, the list's effectively stateless since all of the state was moved out of the component.
                Revert the list class definition to inherit the default state:
            </p>
            <code>@JsExport
                class VideoList : RComponent&amp;lt;VideoListProps, RState&amp;gt;()
            </code>
            <p>Expand the <code>VideoListProps</code> interface to contain the <code>selectedVideo</code>. It's
                necessary to pass down the overarching state using a prop:
            </p>
            <code>external interface VideoListProps : RProps {
                var videos: List&amp;lt;Video&amp;gt;
                var selectedVideo: Video?
                }
            </code>
            <p>Fix the condition for the triangle highlight to use props instead of state:</p>
            <code>if(video == props.selectedVideo) {
                + &amp;quot;â–¶&amp;quot;
                }
            </code>
        </chapter>
        <chapter id="pass-handlers" title="Pass handlers">
            <p>Now there's no access to the parent component's state, so the setState lambda for the <code>
                onClickFunction()
            </code> doesn't actually work. To fix this and get the app running, you need the state lifting again.
                Altering the state of the parent component is not allowed in React. To solve the problem of modifying
                the application state from within a component, you can move the logic for handling user interaction into
                a prop and passing it in from the parent. Remember that in Kotlin, variables can have the <a
                        href="https://kotlinlang.org/docs/reference/lambdas.html#function-types">type of a function</a>.
            </p>
            <list type="decimal">
                <li>Expand the <code>VideoListProps interface</code> so that it contains a variable <code>
                    onSelectVideo()</code>, which is a function from Video returning <code>Unit</code>:
                </li>
            </list>
            <code>external interface VideoListProps : RProps {
                var videos: List&amp;lt;Video&amp;gt;
                var selectedVideo: Video?
                var onSelectVideo: (Video) -&amp;gt; Unit
                }
            </code>
            <list start="2" type="decimal">
                <li>Adjust <code>onClickFunction()</code> accordingly to use the prop:
                </li>
            </list>
            <code>onClickFunction = {
                props.onSelectVideo(video)
                }

            </code>
            <list start="3" type="decimal">
                <li>Now, you can pass in the selected video as a prop, and move the logic for selecting a video into the
                    parent component, where modifying the state is allowed.
                    Add the corresponding logic within two <code>videoList</code> usages:
                </li>
            </list>
            <code>videoList {
                videos = unwatchedVideos
                selectedVideo = state.currentVideo
                onSelectVideo = { video -&amp;gt;
                setState {
                currentVideo = video
                }
                }
                }
                ```

                4. Repeat this step for the watched videos list.
                5. Switch back to your browser and check that the selection jumps between the lists when selecting a
                video in the two lists instead of being duplicated.
                &amp;gt; You can find the state of the project after this section on the step-04-composing-components
                branch
                [here](https://github.com/kotlin-hands-on/web-app-react-kotlin-js-gradle/tree/step-04-composing-components).
                &amp;gt;
                {type=&amp;quot; note&amp;quot;}
                ## Add more components
                ### Extract the video player component
                You can now create another self-contained unit, a video player, that is currently visualized by a
                placeholder image.
                The props for the video player, author, talk title, and video link need to be passed to the
                `VideoPlayer` component. This information is already contained within a Video object, so you can pass it
                as a prop and use its attributes accordingly.
                If you write the whole component, including its respective interfaces, you should end up with a file
                called `VideoPlayer.kt` that contains the following:
                &amp;quot;`kotlin
                import kotlinx.css.*
                import kotlinx.html.js.onClickFunction
                import react.*
                import react.dom.*
                import styled.*
                â€‹
                external interface VideoPlayerProps : RProps {
                var video: Video
                }
                â€‹
                @JsExport
                class VideoPlayer : RComponent&amp;lt;VideoPlayerProps, RState&amp;gt;() {
                override fun RBuilder.render() {
                styledDiv {
                css {
                position = Position.absolute
                top = 10.px
                right = 10.px
                }
                h3 {
                +&amp;quot;${props.video.speaker}: ${props.video.title}&amp;quot;
                }
                img {
                attrs {
                src = &amp;quot;https://via.placeholder.com/640x360.png?text=Video+Player+Placeholder&amp;quot;
                }
                }
                }
                }
                }
                â€‹
                fun RBuilder.videoPlayer(handler: VideoPlayerProps.() -&amp;gt; Unit): ReactElement {
                return child(VideoPlayer::class) {
                this.attrs(handler)
                }
                }
                ```

                In `App.kt`, replace the previous snippet, styledDiv that contained the video player, with the
                following:
                ```
                state.currentVideo?.let { currentVideo -&amp;gt;
                videoPlayer {
                video = currentVideo
                }
                }
                &amp;quot;

                Now the video player will only be shown if the `currentVideo` in the application's state is set.
                ### Add a button and wire it
                To make it possible for users to move videos from the list of unwatched videos to the list of watched
                videos (and vice versa), add a button to the `VideoPlayer` component.
                Since moving items between two different lists happens outside the `VideoPlayer` component, the handler
                for the button needs to be lifted and passed in from the outside.
                The button should have different text depending on whether the video has been watched or not. So you
                need to give the button the status of the video passed in:
                Expand the `VideoPlayerProps` interface:
                ```
                external interface VideoPlayerProps : RProps {
                var video: Video
                var onWatchedButtonPressed: (Video) -&amp;gt; Unit
                var unwatchedVideo: Boolean
                }
                ```

                You can use props to adjust CSS properties. In this case, the color of the button is dynamically based
                on the state of the video. Add the following HTML DSL snippet to the `render()` function of VideoPlayer,
                between the `h3` and `img` tags:
                ```
                styledButton {
                css {
                display = Display.block
                backgroundColor = if(props.unwatchedVideo) Color.lightGreen else Color.red
                }
                attrs {
                onClickFunction = {
                props.onWatchedButtonPressed(props.video)
                }
                }
                if(props.unwatchedVideo) {
                +&amp;quot;Mark as watched&amp;quot;
                }
                else {
                +&amp;quot;Mark as unwatched&amp;quot;
                }
                }
                ```
                ### Move video lists to the application state
                Now it's time to adjust the usage site for the VideoPlayer. When the button is clicked, a video should
                either be moved from the unwatched list to the watched list or vice versa.
                Since these lists can now actually change, move them into the application state:
                Expand the interface with a couple more lines:
                ```
                external interface AppState : RState {
                var currentVideo: Video?
                var unwatchedVideos: List&amp;lt;Video&amp;gt;
                var watchedVideos: List&amp;lt;Video&amp;gt;
                }
                ```
                Fill the state with some predefined values from within the init method. To do that, add an override to
                the body of the `App` class:
                ```
                override fun AppState.init() {
                unwatchedVideos = listOf(
                KotlinVideo(1, &amp;quot;Building and breaking things&amp;quot;, &amp;quot;John Doe&amp;quot;, &amp;quot;https://youtu.be/PsaFVLr8t4E&amp;quot;),
                KotlinVideo(2, &amp;quot;The development process&amp;quot;, &amp;quot;Jane Smith&amp;quot;, &amp;quot;https://youtu.be/PsaFVLr8t4E&amp;quot;),
                KotlinVideo(3, &amp;quot;The Web 7.0&amp;quot;, &amp;quot;Matt Miller&amp;quot;, &amp;quot;https://youtu.be/PsaFVLr8t4E&amp;quot;)
                )
                watchedVideos = listOf(
                KotlinVideo(4, &amp;quot;Mouseless development&amp;quot;, &amp;quot;Tom Jerry&amp;quot;, &amp;quot;https://youtu.be/PsaFVLr8t4E&amp;quot;)
                )
                }
                ```
                Now you can delete the original file-level declarations for `unwatchedVideos` and `watchedVideos` in
                `Main.kt`. Follow the compiler errors to replace all references to `(un)watchedVideos` in the
                `videoList` invocations and replace them with state `(un)watchedVideos` inside `App.kt`.
                The `videoPlayer` call site should look like this:
                ```
                videoPlayer {
                video = currentVideo
                unwatchedVideo = currentVideo in state.unwatchedVideos
                onWatchedButtonPressed = {
                if (video in state.unwatchedVideos) {
                setState {
                unwatchedVideos -= video
                watchedVideos += video
                }
                } else {
                setState {
                watchedVideos -= video
                unwatchedVideos += video
                }
                }
                }
                }
                ```
                Check your browser, select a video, and hit the button a few times. The element should switch between
                the two lists.
                Feel free to change the styles for the button, adjust it, and maybe try extracting the button as its own
                reusable component.
                &amp;gt; You can find the state of the project after this section on the step-05-more-components branch
                [here](https://github.com/kotlin-hands-on/web-app-react-kotlin-js-gradle/tree/step-05-more-components).
                &amp;gt;
                {type=&amp;quot; note&amp;quot;}
                ## Use packages from NPM
                To make the app work, you still need a video player. React has a rich ecosystem with a lot of ready-made
                components you can use instead of writing everything from scratch yourself.
                ### Add the video player component
                To replace the placeholder video component with one that can show the linked YouTube videos, add in a
                ready-made video player for React. For example, the `react-youtube-lite` component that can show video
                and control the appearance of the player.
                For the component documentation and the API description, see its
                [README](https://www.npmjs.com/package/react-youtube-lite) in GitHub.
                Check the `build.gradle(.kts)` file. In the beginning, you've already added the `react-youtube-lite`
                package:
                ```
                dependencies {
                //...
                //Video Player
                implementation(npm(&amp;quot;react-youtube-lite&amp;quot;, &amp;quot;1.0.1&amp;quot;))
                //...
                }
                ```

                As you can see, NPM dependencies can be added to a Gradle build file via the `npm()` function. The yarn
                installation managed by the Gradle plugin will take care of downloading, installing and updating those
                NPM dependencies for you.
                To use this module from Kotlin, create a file called `ReactYouTube.kt`, with the following contents:
                ```
                @file:JsModule(&amp;quot;react-youtube-lite&amp;quot;)
                @file:JsNonModule
                â€‹
                import react.*
                â€‹
                @JsName(&amp;quot;ReactYouTubeLite&amp;quot;)
                external val reactPlayer: RClass&amp;lt;dynamic&amp;gt;
                ```
                It's necessary to tell the compiler about the component interface, what can be invoked, set, or read
                from this external component so that everything's safe and you can count on tool support.
                The last two lines are equivalent to a JavaScript import like `require(&amp;quot;react-youtube-lite&amp;quot;).default;`.
                It tells the compiler that it's certain that there'll be a component conforming to `RClass&amp;lt;dynamic&amp;gt;`
                at runtime.
                However, in this configuration, the declaration of dynamic instructs the compiler to accept the
                component as is at the risk of breaking things at runtime (in production).
                You can infer the structure of the interfaces used by the imported components from the
                [README](https://www.npmjs.com/package/react-youtube-lite)) to make wrappers typesafe. Define a typesafe
                external interface allowing to set the URL as needed:
                Modify the ReactPlayer definition to :
                ```
                @file:JsModule(&amp;quot;react-youtube-lite&amp;quot;)
                @file:JsNonModule
                â€‹
                import react.*
                â€‹
                @JsName(&amp;quot;ReactYouTubeLite&amp;quot;)
                external val reactPlayer: RClass&amp;lt;ReactYouTubeProps&amp;gt;
                â€‹
                external interface ReactYouTubeProps : RProps {
                var url: String
                }
                ```
                Within the `VideoPlayer` class, replace the `img` tag with:
                ```
                reactPlayer {
                attrs.url = props.video.videoUrl
                }
                ```
                ### Add social share buttons
                An easy way to share the content in the application is to have social share buttons for messengers and
                email. You can use an off-the-shelf React component for this as well, for example,
                [react-share](https://github.com/nygardk/react-share/blob/master/README.md).
                Check your Gradle configuration. For this package, there's already a corresponding snippet:
                ```
                dependencies {
                //...
                //Share Buttons
                implementation(npm(&amp;quot;react-share&amp;quot;, &amp;quot;~4.2.1&amp;quot;))
                //...
                }
                ```
                [Examples on GitHub](https://github.com/nygardk/react-share/blob/master/demo/Demo.jsx#L61) show that a
                share button consists of two react components: `EmailShareButton` and `EmailIcon`, for example. However,
                all of them share (mostly) the same interface.
                If you add more wrappers, your `ReactShare.kt` declaration will look like this:
                ```
                @file:JsModule(&amp;quot;react-share&amp;quot;)
                @file:JsNonModule
                â€‹
                import react.RClass
                import react.RProps
                â€‹
                @JsName(&amp;quot;EmailIcon&amp;quot;)
                external val emailIcon: RClass&amp;lt;IconProps&amp;gt;
                â€‹
                @JsName(&amp;quot;EmailShareButton&amp;quot;)
                external val emailShareButton: RClass&amp;lt;ShareButtonProps&amp;gt;
                â€‹
                @JsName(&amp;quot;TelegramIcon&amp;quot;)
                external val telegramIcon: RClass&amp;lt;IconProps&amp;gt;
                â€‹
                @JsName(&amp;quot;TelegramShareButton&amp;quot;)
                external val telegramShareButton: RClass&amp;lt;ShareButtonProps&amp;gt;
                â€‹
                external interface ShareButtonProps : RProps {
                var url: String
                }
                â€‹
                external interface IconProps : RProps {
                var size: Int
                var round: Boolean
                }
                ```
                Above the reactPlayer usage site in `VideoPlayer.kt`, add the two share buttons (in a styledDiv for a
                layout).
                ```
                styledDiv {
                css {
                display = Display.flex
                marginBottom = 10.px
                }
                emailShareButton {
                attrs.url = props.video.videoUrl
                emailIcon {
                attrs.size = 32
                attrs.round = true
                }
                }
                telegramShareButton {
                attrs.url = props.video.videoUrl
                telegramIcon {
                attrs.size = 32
                attrs.round = true
                }
                }
                }
                ```
                You can now check that the buttons actually work by clicking one of them and seeing if the corresponding
                share window opens. If you don't see anything, you may need to disable your social / ad blocker for it
                to work.


                Feel free to repeat this step with some of the other share buttons [offered by the
                component](https://github.com/nygardk/react-share/blob/master/README.md#features).
                &amp;gt; You can find the state of the project after this section on the step-06-packages-from-npm
                branch
                [here](https://github.com/kotlin-hands-on/web-app-react-kotlin-js-gradle/tree/step-06-packages-from-npm).
                &amp;gt;
                {type=&amp;quot; note&amp;quot;}
                ## Use an external REST API
                You can substitute mock data by obtaining information from a REST API to display the videos and render
                your application.
                For this tutorial, there's a [small
                API](https://my-json-server.typicode.com/kotlin-hands-on/kotlinconf-json/videos/1). It offers only a
                single endpoint, videos, and takes a numeric parameter to access an element from the list. Feel free to
                try out this rather limited API in the browser. You will see that the objects returned from the API
                follow the same structure as Video objects.
                ### Use JS functionality from Kotlin
                Even without pulling in external libraries, browsers already come with a lot of functionality. Wrappers
                for those APIs are included with Kotlin/JS. They make it easy to access the available functionality in a
                comfortable and type-safe way straight from your Kotlin code. One example of these wrappers is the
                functionality for consuming making HTTP requests (arguably the most important part in consuming a
                RESTful service), in particular, the [fetch
                API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).
                The typical way to do asynchronous programming in JavaScript is through the use of callbacks. This means
                resolving promises step by step using functions stacked inside of other functions. The more complex your
                code gets, the more heavily indented it will be. This approach makes the code harder to parse and to
                understand the control flow.
                Instead, you can use Kotlin coroutines, a much nicer and more structured way for such functionality.
                ### Make use of coroutines instead of callbacks
                Check the `build.gradle(.kts)` file. The relevant snippet should already exist in your configuration
                from back when you set up the project:
                ```
                dependencies {
                //...
                //Coroutines
                implementation(&amp;quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.9&amp;quot;)
                }
                ```
                Inside `App.kt` (or a new file), write a method to fetch a video from the API.
                ```
                suspend fun fetchVideo(id: Int): Video {
                val response = window
                .fetch(&amp;quot;https://my-json-server.typicode.com/kotlin-hands-on/kotlinconf-json/videos/$id&amp;quot;)
                .await()
                .json()
                .await()
                return response as Video
                }
                ```
                Suspending function fetches a video from the API given an id, waits for it to be available, turns it
                into a JSON, waits again for the completion of that operation, and returns it â€“ but before, it casts it
                to the external interface Video, which was defined earlier.
                You will see a warning for this unchecked cast â€“ but this is in the nature of using a JavaScript
                definition like fetch: The compiler can't know for sure that an instance of Video is returned.
                Use quick fixes to import the required objects and functions, or manually add them to the top of
                `App.kt`:
                ```
                import kotlinx.browser.window
                import kotlinx.coroutines.*
                ```
                A function call like `window.fetch` returns a Promise object. You would have to define a callback
                handler that gets invoked once the Promise is resolved and a result is available.
                However, with coroutines, you can await those promises. Whenever a function like `await()` is called,
                the method stops (suspends) its execution. It continues execution once the Promise can be resolved.
                To work with multiple lists of videos, you can define a function `fetchVideos()`, which will fetch 25
                videos from the same API as above. To run all the requests concurrently, use the async functionality
                provided by coroutines:
                ```
                suspend fun fetchVideos(): List&amp;lt;Video&amp;gt; = coroutineScope {
                (1..25).map { id -&amp;gt;
                async {
                fetchVideo(id)
                }
                }.awaitAll()
                }
                ```
                For reasons of [structured
                concurrency](https://kotlinlang.org/docs/reference/coroutines/basics.html#structured-concurrency), the
                implementation is wrapped in a coroutineScope. You can then start 25 asynchronous tasks (one per
                request) and wait for them to complete.
                You can now add the data to your application. To do this, expand the `init()` function of `App`:
                ```
                override fun AppState.init() {
                unwatchedVideos = listOf()
                watchedVideos = listOf()
                â€‹
                val mainScope = MainScope()
                mainScope.launch {
                val videos = fetchVideos()
                setState {
                unwatchedVideos = videos
                }
                }
                }
                ```
                &amp;gt; Inside the `init()` function, setState is used to set the unwatchedVideos to the result of the
                &amp;gt; coroutine. The setState invocation is necessary to refresh the rendered result, as the app has
                &amp;gt; most likely already finished rendering an empty list of `unwatchedVideos`.
                &amp;gt;
                {type=&amp;quot; note&amp;quot;}

                Check your browser. The application should show actual data.

                If you want to get an in-depth understanding of how coroutines work, check this [hands-on on
                coroutines](https://play.kotlinlang.org/hands-on/Introduction%20to%20Coroutines%20and%20Channels/).
                &amp;gt; You can find the state of the project after this section on the step-07-using-external-rest-api
                branch
                [here](https://github.com/kotlin-hands-on/web-app-react-kotlin-js-gradle/tree/step-07-using-external-rest-api).
                &amp;gt;
                {type=&amp;quot; note&amp;quot;}
                ## Deploy to production and the cloud
                It's time to get the application published to the cloud and make it accessible for other people.
                ### Package a production build
                To package all assets in production mode, run the build task in Gradle via the tool window in IntelliJ
                IDEA or by running `./gradlew` build.
                This generates an optimized build of your project, applying various improvements such as DCE (dead code
                elimination). Several static files ready for deployment will appear inside the `/build/distributions`
                folder. They include the JS files, HTML files, and other resources required to run the application. You
                can put them on a static HTTP server, serve them using GitHub Pages, or host them on a cloud provider of
                your choice.
                ### Deploy to Heroku
                Heroku makes it quite simple to spin up an application that is reachable under its own domain. Their
                free tier should be enough for development purposes.
                1. [Create an account](https://signup.heroku.com/)
                2. [Install and authenticate the CLI client](https://devcenter.heroku.com/articles/heroku-cli)
                3. Create a git repository and attach a Heroku app by running the following commands in the Terminal
                while in the project root:
                `git init heroku create git add . git commit -m &amp;quot;initial commit&amp;quot;`
                4. Unlike a regular JVM application that would run on Heroku (for example, written with Ktor or Spring
                Boot), your app generates static HTML pages and JS files that need to be served accordingly. You can
                adjust the required buildpacks to serve the program properly:
                ```
                heroku buildpacks:set heroku/gradle heroku buildpacks:add
                https://github.com/heroku/heroku-buildpack-static.git
                ```
                5. To allow the heroku/gradle buildpack to run properly, a stage task needs to be present in the Gradle
                build file. It's equivalent to the build task, and the corresponding alias is already included at the
                bottom of the Gradle build file:
                ```
                // Heroku Deployment
                tasks.register(&amp;quot;stage&amp;quot;) {
                dependsOn(&amp;quot;build&amp;quot;)
                }
                ```
                5. Configure the buildpack-static by adding a file called static.json to the root of the project. Add
                the root property inside the file as follows:
                ```
                {
                &amp;quot;root&amp;quot;: &amp;quot;build/distributions&amp;quot;
                }
                ```
                You can now trigger a deployment, for example, by running the following command:
                `git add -A git commit -m &amp;quot;add stage task and static content root configuration&amp;quot; git
                push heroku master`
                If you're pushing from a non-master branch (such as the step branches from the example repository), you
                need to adjust the command to push to the master remote. (such as `git push heroku
                step-08-deploying-to-production:master`)
                If everything's OK, you will see the URL under which it's possible to reach the application on the
                internet.

                &amp;gt; You can find the state of the project after this section on the final branch
                [here](https://github.com/kotlin-hands-on/web-app-react-kotlin-js-gradle/tree/final).
                &amp;gt;
                {type=&amp;quot; note&amp;quot;}
                ## Addendum: Modern React with Hooks
                React 16.8 introduced [Hooks](https://reactjs.org/docs/hooks-intro.html) as a novel way of using state
                and other React features without writing a class. The Kotlin wrappers for React also support working
                with Hooks.
                The two most commonly used Hooks built into React are the State and Effect Hooks. Like other hooks, they
                are used in the context of functional components.
                ### Function components
                Conceptually, React's function components themselves aren't very complex. They simply contain the
                instructions of how to render a React component in a single function based on the properties passed in
                and don't rely on a surrounding class structure. A very simple function component could look something
                like this in Kotlin:
                ```
                external interface WelcomeProps: RProps {
                var name: String
                }
                â€‹
                val welcome = functionalComponent&amp;lt;WelcomeProps&amp;gt; { props -&amp;gt;
                h1 {
                +&amp;quot;Hello, ${props.name}&amp;quot;
                }
                }
                ```
                Just like with class components, properties are defined as an external interface. It's passed to the
                `functionalComponent` builder as a generic argument. Inside the builder, you can write code similar to
                the `render()` function in class components â€“ you have access to RBuilder functions and can use the
                passed-in props.
                Similar to how class components, you can use the child function to add this welcome component to a
                parent component:
                ```
                child(welcome) {
                attrs.name = &amp;quot;Kotlin&amp;quot;
                }
                ```
                If you find this call site too cumbersome, you can create an `RBuilder()` extension function that takes
                a handler function, allowing to write welcome { name = &amp;quot;Kotlin&amp;quot;} whenever the
                component is used:
                ```
                fun RBuilder.welcome(handler: WelcomeProps.() -&amp;gt; Unit) = child(welcome) {
                attrs {
                handler()
                }
                }
                ```
                However, in this implementation function, components are still constrained. They show their full
                potential when combined with Hooks.
                ### The State Hook
                You can use the State Hook to keep track of the state without a class component. Consider the following
                implementation of a counter inside a `functionalComponent`:
                ```
                val counter = functionalComponent&amp;lt;RProps&amp;gt; {
                val (count, setCount) = useState(0)
                button {
                attrs.onClickFunction = { setCount(count + 1) }
                +count.toString()
                }
                }
                ```
                `useStat`\ is called with an initial value 0 â€“ meaning the type is automatically inferred to be `Int`.
                You can also specify the type explicitly, which is especially useful when working with nullable values
                (`useState&amp;lt;String?&amp;gt;(null)`).
                Calling `useState` returns a pair (that is directly destructured): a reference to the current state
                (here, count of type `Int`) and a function that can be used to set the state (here, `setCount()` of type
                `RSetState&amp;lt;Int&amp;gt;`).
                Unlike properties in a React class component, the `setCount()` function can be called without using a
                `setState` lambda.
                React makes sure that the lifecycle is handled properly: that the count variable is only initialized
                with its initial value once and that subsequent renderings use the correct updated state. It makes the
                work with the framework easier â€“ you don't have to worry about providing separate initializer functions,
                for example.
                To learn more about the State Hook, check out the [official React
                documentation](https://reactjs.org/docs/hooks-state.html).
                ### The Effect Hook
                The Effect Hook can be useful for performing side effects in a functional component â€“ like querying an
                API or establishing a connection. Consider the following implementation of a `functionalComponent` which
                fetches a random fact and displays it in an `h3` tag:
                ```
                val randomFact = functionalComponent&amp;lt;RProps&amp;gt; {
                val (randomFact, setRandomFact) = useState&amp;lt;String?&amp;gt;(null)
                useEffect(emptyList()) {
                GlobalScope.launch {
                val fortyTwoFact = window.fetch(&amp;quot;http://numbersapi.com/42&amp;quot;).await().text().await()
                setRandomFact(fortyTwoFact)
                }
                }
                h3 { +(randomFact ?: &amp;quot;Fetching...&amp;quot;) }
                }
                ```
                To keep track of the API result, previously introduced State Hook is used. Then you call `useEffec't,
                run the call to the API, and use the `setRandomFact()` function provided by the State Hook to update the
                stored result.
                `useEffect` is called with its first parameter, its dependencies. Dependencies simply describe the props
                or state which needs to change in order for the Effect Hook to be run again. In this case, you only need
                to make the call to the external API once, regardless of other state changes in the application, so an
                `emptyList()` is passed.

                If you omitted `emptyList`(), your Effect Hook would be called after each invocation of `setRandomFact`,
                resulting in an endless loop.
                To learn more about these nuances and other details of the Effect Hook and how it relates to the
                classical React lifecycle, check out the [official React
                documentation](https://reactjs.org/docs/hooks-effect.html).
                ### Try out Hooks
                If you want, you can try converting some of the components in your application â€“ like the `videoList` â€“
                to a functional component that uses the new Hooks API. While the `useState` hook will likely come in
                handy for almost all components, the `useEffect` hook will be especially important for interacting with
                external APIs.
                Class-based components and function components can easily coexist in the same React application â€“ so you
                can also consider writing a new functional component and adding it to the application.
                ## What's next
                ### Add more features
                You can use the resulting app as a jumping-off point to explore more advanced topics in the realm of
                React, Kotlin/JS, and more.
                **Search**. You can add a search field to filter the list of talks by title or by author, for example.
                It's a great way to learn about how [HTML form elements work in
                React](https://reactjs.org/docs/forms.html).
                **Persistence**. For now, the application loses track of the viewer's watch list every time the page
                gets reloaded. Familiarize yourself with one of the web frameworks available for Kotlin (like
                [Ktor](https://ktor.io/)), and try writing a backend for your application that can save the list of
                watched and unwatched videos. Or maybe there is a way to [store information on the
                client](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage).
                **Complex APIs**. There are lots of datasets and APIs available. You can pull any data into your
                application by building a visualizer for [cat photos](https://thecatapi.com/) or a [royalty-free stock
                photo API](https://unsplash.com/developers) for example.
                ### Improve the style: responsiveness and grids
                The final product still doesn't fare well under extreme layout circumstances, for example, in narrow
                windows or on phone screens. CSS Grids might be a fun way to explore how to make the app responsive.
                Bonus challenge: try without media queries.
                ### Try more libraries
                In the [kotlin-wrappers](https://github.com/JetBrains/kotlin-wrappers) repository, you can find some
                more wrappers and basic information about how to get started with additional libraries that have
                official Kotlin bindings, for example:
                [React-Redux](https://github.com/JetBrains/kotlin-wrappers/tree/master/kotlin-react-redux)
                [React-Router-DOM](https://github.com/JetBrains/kotlin-wrappers/tree/master/kotlin-react-router-dom)
                ### Join the community and get help
                The best way to get help with this tutorial is to visit the official [YouTrack issue
                tracker](https://youtrack.jetbrains.com/issues/CRKA). If you can't find your problem, file a new issue.
                You can also join the official [Kotlin Slack](https://surveys.jetbrains.com/s3/kotlin-slack-sign-up).
                There are channels for #javascript, #react, and more.
                ### Learn more about coroutines
                If you're interested in finding out more about how you can write concurrent code, check out the hands-on
                lab on
                [coroutines](https://play.kotlinlang.org/hands-on/Introduction%20to%20Coroutines%20and%20Channels/01_Introduction).
                ### Learn more about React
                Now that you know the basic concepts and how they translate to Kotlin, you can convert some of the other
                concepts outlined in the [official guides on React](https://reactjs.org/docs/) into Kotlin.


            </code>
        </chapter>
    </chapter>
</topic>