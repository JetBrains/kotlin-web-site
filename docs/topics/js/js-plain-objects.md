[//]: # (title: JS Plain Objects compiler plugin)

<primary-label ref="experimental-general"/>

This page explains how to use the JS Plain Objects Kotlin compiler plugin for Kotlin/JS projects. 
The plugin helps you create and copy plain JavaScript objects in a type-safe way.

> The `js-plain-objects` compiler plugin only works with the new K2 Kotlin compiler.
>
{style="warning"}

## What is a "plain JavaScript object"?

A plain object is a simple JavaScript object created via an object literal (`{}`) that contains data properties.
Many JS APIs accept/return such objects for configuration or data exchange.

With this plugin, you declare a Kotlin external interface to describe the object shape and annotate it with `@JsPlainObject`.
The compiler then generates convenient functions to build and copy such objects while preserving Kotlin type safety.

## Enable the plugin

Add the Gradle plugin to your project (Kotlin DSL shown):

```kotlin
// build.gradle.kts
plugins {
    kotlin("multiplatform") version "%kotlin.version%"
    kotlin("plugin.js-plain-objects") version "%kotlin.version%"
}

kotlin {
    js {
        browser() // or nodejs()
    }
}
```

Groovy DSL:

```groovy
// build.gradle
plugins {
    id 'org.jetbrains.kotlin.multiplatform' version '%kotlin.version%'
    id 'org.jetbrains.kotlin.plugin.js-plain-objects' version '%kotlin.version%'
}

kotlin {
    js {
        browser() // or nodejs()
    }
}
```

## Declare a plain object type

Annotate an external interface with `@JsPlainObject`. For example:

```kotlin
@JsPlainObject
external interface User {
    val name: String
    val age: Int
    val email: String? // you can use nullable types to declare a property as optional
}
```

When the plugin processes such an interface, it generates a companion object with two helper functions:

```kotlin
@JsPlainObject
external interface User {
    val name: String
    val age: Int
    val email: String?

    // Generated by the plugin
    @JsExport.Ignore
    companion object {
        inline operator fun invoke(name: String, age: Int, email: String? = NOTHING): User =
            js("({ name: name, age: age, email: email })")

        inline fun copy(source: User, name: String = NOTHING, age: Int = NOTHING, email: String? = NOTHING): User =
            js("Object.assign({}, source, { name: name, age: age, email: email })")
    }
}
```

Notes:
- `name` and `age` are declared without nullability mark, so they are required.
- `email` is declared as nullable, so it's optional and can be skipped during creation.
- The operator `invoke` builds a new plain JS object with the provided properties.
- The `copy` function creates a new object by shallow-copying `source` and overriding any specified properties.
- The companion is marked with `@JsExport.Ignore` to avoid leaking these helpers into JS exports.

## Usage

Create and copy objects using the generated helpers:

```kotlin
fun main() {
    val user = User(name = "Name", age = 10)
    val copy = User.copy(user, age = 11, email = "some@user.com")

    println(JSON.stringify(user))
    // { "name": "Name", "age": 10 }
    println(JSON.stringify(copy))
    // { "name": "Name", "age": 11, "email": "some@user.com" }
}
```

The Kotlin code compiles to JavaScript similar to:

```javascript
function main() {
  var user = { name: "Name", age: 10 };
  var copy = Object.assign({}, user, { age: 11, email: "some@user.com" });

  println(JSON.stringify(user));
  // { "name": "Name", "age": 10 }
  println(JSON.stringify(copy));
  // { "name": "Name", "age": 11, "email": "some@user.com" }
}
```

Any JavaScript objects created with this approach are safer. You will have a compile-time error if you use a wrong
property name or value type, and zero-cost since the generated code is inlined as a simple object literal and `Object.assign` calls.

## See also

Learn more in the [Use JavaScript code from Kotlin](js-interop.md) and [dynamic type](dynamic-type.md) documentation that covers the interoperability with JavaScript in detail.
