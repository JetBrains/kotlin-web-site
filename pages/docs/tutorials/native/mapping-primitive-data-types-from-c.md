---
type: tutorial
layout: tutorial
title:  "Mapping Primitive Data Types from C"
description: "Primitive Data types from C and how they look in Kotlin/Native"
authors: Eugene Petrenko 
date: 2018-07-23
showAuthorInfo: false
issue: EVAN-5343
---

In this tutorial, we learn what C data types are visible in Kotlin/Native and vice versa. We will: 
- See what [Data Types are in C Language](#types-in-c-language)
- Create a [tiny C Library](#an-example-c-library) that uses those types in exports
- [Inspect Generated Kotlin APIs from a C library](#inspecting-generated-kotlin-apis-for-a-c-library)
- Find how [Primitive Types in Kotlin](#primitive-types-in-kotlin) are mapped to C

## Types in C Language

What types do we have in the C language? Let's first list all of them. I have used the
[C data types](https://en.wikipedia.org/wiki/C_data_types) article from Wikipedia as a basis.
There are following types in the C programming language:
- basic types `char, int, float, double` with modifiers `signed, unsigned, short, long` 
- structures, unions, arrays
- pointers
- function pointers

There are also more specific types:
- boolean type (from [C99](https://en.wikipedia.org/wiki/C99))
- `size_t` and `ptrdiff_t` (also `ssize_t`)
- fixed width integer types, e.g., `int32_t` or `uint64_t` (from [C99](https://en.wikipedia.org/wiki/C99))

There are also the following type qualifiers in the C language: `const`, `volatile`, `restruct`, `atomic`.

The best way to see what C data types are visible in Kotlin is to try it

## An Example C Library

We create a `lib.h` file to see how C functions are mapped into Kotlin:
<div class="sample" markdown="1" mode="c" theme="idea" data-highlight-only="1" auto-indent="false">

```c
#ifndef LIB2_H_INCLUDED
#define LIB2_H_INCLUDED

void ints(char c, short d, int e, long f);
void uints(unsigned char c, unsigned short d, unsigned int e, unsigned long f);
void doubles(float a, double b);

#endif
```
</div>

The file is missing the `extern "C"` block, which is not needed for our example, but may be 
necessary if we use C++ and overloaded functions. The 
[C++ compatibility](https://stackoverflow.com/questions/1041866/what-is-the-effect-of-extern-c-in-c)
thread contains more details on this.

For every set of `.h` files,
we will be using the `cinterop` [C Libraries](/docs/reference/native/c_interop.html)
from Kotlin/Native to generate a Kotlin/Native library,
or `.klib`. The generated library will bridge calls from Kotlin/Native to C. It includes
respective Kotlin declarations for the definitions form the `.h` files.
It is only necessary to have a `.h` file to run the `cinterop` tool. And we do not need to create a 
`lib.c` file, unless we want to compile and run the example.
More details on this are covered in the [C Libraries](/docs/reference/native/c_interop.html) page. It is enough for
the tutorial to create the `lib.def` file with the following content:
<div class="sample" markdown="1" mode="c" theme="idea" data-highlight-only="1" auto-indent="false">

```c
headers = lib.h
```
</div>

We may include all declarations directly into the `.def` file after a `---` separator.
It can be helpful to include macros or other C defines into the code generated by the `cinterop` tool.
Method bodies are compiled and fully included into the binary too. Let's use
that feature to have a runnable example without a need for a C compiler.
To implement that, we need to add implementations to the C functions from the `lib.h` file,
and place these functions into a `.def` file.
We will have the following `interop.def` result:
<div class="sample" markdown="1" mode="c" theme="idea" data-highlight-only="1" auto-indent="false">

```c

---

void ints(char c, short d, int e, long f) { }
void uints(unsigned char c, unsigned short d, unsigned int e, unsigned long f) { }
void doubles(float a, double b) { }
```
</div>

The `lib-with-code.def` file is enough to compile and run the application or open it in an IDE.
Now it is time to create project files, open the project in
[IntelliJ IDEA](https://jetbrains.com/idea) and run it. 

## Inspecting Generated Kotlin APIs for a C library

While it is certainly possible to use the command line, be it directly or
combine it with a script file (i.e. bash or bat file), we should notice,
that it does not scale well for bigger projects with hundreds of files and libraries.
It is more recommendable to use the Kotlin/Native compiler is with a build system which
helps by downloading and caching the Kotlin/Native compiler binaries and libraries with
transitive dependencies, and it runs the compiler and tests.
Kotlin/Native uses the [Gradle](https://gradle.org) build system through the
[kotlin-multiplatform](/docs/reference/building-mpp-with-gradle.html) plugin.

We cover the basics of an IDE compatible project setup with Gradle in the
[A Basic Kotlin/Native Application](basic-kotlin-native-app.html#create-gradle-project)
tutorial. Please check that out to see the detailed first steps
and instructions to start a new Kotlin/Native project and open it in IntelliJ IDEA.
In this tutorial we'll see advanced C interop related usages of the Kotlin/Native 
and
[multiplatform](/docs/reference/building-mpp-with-gradle.html)
builds with Gradle.

Let's first create a project folder. All the paths in this tutorial will be relative to this folder. Sometimes
the missing directories will have to be created before new files are added.

We'll use the following 
<span class="multi-language-span" data-lang="groovy">
`build.gradle` 
</span>
<span class="multi-language-span" data-lang="kotlin">
`build.gradle.kts` 
</span>
Gradle build file with the following contents:
[[include pages-includes/docs/tutorials/native/mapping-primitive-data-types-from-c-code.md]]

You may also download the project skeleton directly from 
[[include pages-includes/docs/tutorials/native/mapping-primitive-data-types-from-c-link.md]]


The project file configures C interop as an additional step of the build.
Let's move the `interop.def` file under the `src/nativeInterop/cinterop` directory.
Gradle recommends using conventions instead of configurations,
for example, the sources path it `src/nativeMain/kotlin` and the 
`.def` file is expected in `src/nativeInterop/cinterop/interop.def`.
By default, all symbols from C are imported to the `interop` package,
we may want to import the whole package in our `.kt` files.
Check out the [kotlin-multiplatform](/docs/reference/building-mpp-with-gradle.html)
plugin documentation to learn the ways to configure it.

Let's create a `src/nativeMain/kotlin/hello.kt` stub file with the following content
to see how C primitive type declarations are visible from Kotlin:

<div class="sample" markdown="1" theme="idea" data-highlight-only>

```kotlin
import interop.*

fun main() {
  println("Hello Kotlin/Native!")
  
  ints(/* fix me*/)
  uints(/* fix me*/)
  doubles(/* fix me*/)
}
```
</div>

Now we are ready to
[open the project in IntelliJ IDEA](basic-kotlin-native-app.html#open-in-ide)
and to see how to fix the example project. While doing that,
we'll examine how C primitive types are mapped into Kotlin/Native.

## Primitive Types in Kotlin

With the help of IntelliJ IDEA's _Goto Declaration_ or
compiler errors we see the following generated API for our C functions:

<div class="sample" markdown="1" theme="idea" data-highlight-only="1" auto-indent="false">

```kotlin
fun ints(c: Byte, d: Short, e: Int, f: Long)
fun uints(c: UByte, d: UShort, e: UInt, f: ULong)
fun doubles(a: Float, b: Double)
```
</div>

C types are mapped in the way we would expect, note that `char` type is mapped to `kotlin.Byte` 
as it is usually an 8-bit signed value.

| C | Kotlin |
|---|--------|
| char  |  kotlin.Byte |
| unsigned char  |  kotlin.UByte |
| short |  kotlin.Short |
| unsigned short |  kotlin.UShort |
| int   |  kotlin.Int |
| unsigned int   |  kotlin.UInt |
| long long  |  kotlin.Long |
| unsigned long long |  kotlin.ULong |
| float |  kotlin.Float |
| double | kotlin.Double |
{:.zebra}


## Fixing the Code

We see all definitions and it is the time to fix the code. We may run the code via the following
command:
[[include pages-includes/docs/tutorials/native/runDebugExecutableNative.md]]

The final code in the `hello.kt` file may look like that:
 
<div class="sample" markdown="1" theme="idea" data-highlight-only>

```kotlin
import interop.*

fun main() {
  println("Hello Kotlin/Native!")
  
  ints(1, 2, 3, 4)
  uints(5, 6, 7, 8)
  doubles(9.0f, 10.0)
}
```
</div>

## Next Steps

We will continue to explore more complicated C language types and their representation in Kotlin/Native
in the next tutorials:
- [Mapping Struct and Union Types from C](mapping-struct-union-types-from-c.html)
- [Mapping Function Pointers from C](mapping-function-pointers-from-c.html)
- [Mapping Strings from C](mapping-strings-from-c.html)

The [C Interop documentation](/docs/reference/native/c_interop.html)
documentation covers more advanced scenarios of the interop.
