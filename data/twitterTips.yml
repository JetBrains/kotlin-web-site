# Please wrap tweets with "  " (double quotes). If you need to use quotes inside a tweet, either use \" to escape it or use single quotes
# New tweets should be added under -pending
-pending:
  - "Declare immutable value with 'val' and mutable variable with 'var', either in class, function or top-level."
  - "I can't have a fact for today, because type system forbids me from passing null to not-null parameter."
  - "There are 82 contributors to https://github.com/JetBrains/kotlin/ … and only 12 full-time JetBrains developers working on it."
  - "You can pass functional literal to Java method expecting interface with single method. Compiler implements interface for you."
  - "Non-public functions and properties can omit type specification, it will be inferred: 'class C { val x = 1 + 1 }'"
  - "Missing C# events? Define them with simple DSL: https://gist.github.com/orangy/11178911"
  - "'if' is an expression, so you can use it like ternary operator: 'fun fn(a : Boolean, b : String, c : String) = if (a) b else c'"
  - "Powerful 'when' expression is replacing complex switch/case statements, and allows for multiple type checks with automatic cast."
  - "Language doesn't have pattern matching because we figured that it is really needed mostly to compiler developers."
  - "Operators are resolved by convention, so you can provide operators for any type, even 'invoke' for call operator ()"
  - "Interface is a type without a state which you cannot instantiate directly. You can inherit multiple interfaces by a class."
  - "Extension function 'fun String.firstChar() = get(0)' adds firstChar operation to String, and has String as 'this' in the body."
  - "Delegating properties are powerful for many cases: val property by Delegates.lazy { calcProperty() }"
  - "Built-in interface delegation and primary ctor: class ItemsCollection(val items: List<String>) : Iterable<String> by items {}"
  - "Ranges as in 1..10 are useful to iterate over range of numbers, check if value is within range or get string or list subrange."
  - "You can declare local functions and classes with closures, inside another function's body."
  - "Compiler can inline functions with lambdas, when instructed to do so, and thus don't build closures et al. in these cases."
  - "All types and members in Kotlin are sealed (non-inheritable, non-overridable) by default."


-tweeted:
  - description: "By convention, if some type has properties named component1, component2, etc, you can decompose value like 'val (a,b) = pair'"
    date: 2014-07-23
    rt:
  - description: "Instead of init-increment-condition 'for statement', we use for-each style: 'for (x in 0..10)', compiler optimises as needed."
    date: 2014-08-05
    rt: 3
  - description: "Last functional argument of a method can be passed outside of parentheses: https://gist.github.com/orangy/11474248 <— 'using statement' DSL"
    date: 2014-08-14
    rt: 3
  - description: "Autocast helps avoid verbose casts after check types: if (obj is String) return obj.length // obj is String after check"
    date: 2014-08-18
    rt: 3
  - description: "There is no 'new' keyword, creating an instance looks just like function call: val person = Person('John')"
    date: 2014-08-21
    rt: 0
  - description: "There are 258 repositories on @github about/with Kotlin. https://github.com/search?q=kotlin"
    date: 2014-09-01
    rt: 5
  - description: "This is valid code, calling a bunch of functions. No syntax sugar: 'items filter { it.valid } map { it.name}'"
    date: 2014-09-03
    rt: 6
  - description: "'using { ... }' is just a function call, not special syntactic sugar. You can define your own."
    date: 2014-09-05
    rt: 1
  - description: "Unlike in Java, but like C#, there is no binding between file and type/function. You can declare top level functions too"
    date: 2014-09-09
    rt: 1
  - description: "String interpolation makes it easy to build complex formatting: \"My name is $name and I'm ${age.years} years old\""
    date: 2014-09-15
    rt: 1
  - description: "All types and members in Kotlin are sealed (non-inheritable, non-overridable) by default."
    date: 2014-09-17
    rt: 3
  - description: "Missing 'with' from Delphi? :) Standard library has 'public inline fun <T, R> with(receiver: T, f: T.() → R): R = receiver.f()'"
    date: 2014-09-23
    rt: 3
  - description: "Type 'C.(T) → R' is a function type invoked on an instance of type C, gets argument of type T and returns R."
    date: 2014-09-25
    rt:

